; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31942.0 

	TITLE	C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\Distribute\DXTCImage.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0CDXTCImage@@QAE@XZ				; CDXTCImage::CDXTCImage
PUBLIC	??1CDXTCImage@@UAE@XZ				; CDXTCImage::~CDXTCImage
PUBLIC	?Initialize@CDXTCImage@@QAEXXZ			; CDXTCImage::Initialize
PUBLIC	?Clear@CDXTCImage@@QAEXXZ			; CDXTCImage::Clear
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?LoadFromFile@CDXTCImage@@QAE_NPBD@Z		; CDXTCImage::LoadFromFile
PUBLIC	?LoadFromMemory@CDXTCImage@@QAE_NPBEH@Z		; CDXTCImage::LoadFromMemory
PUBLIC	?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEH@Z	; CDXTCImage::LoadHeaderFromMemory
PUBLIC	?Copy@CDXTCImage@@QAE_NHPAEJ@Z			; CDXTCImage::Copy
PUBLIC	?Decompress@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::Decompress
PUBLIC	?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT1
PUBLIC	?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT3
PUBLIC	?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT5
PUBLIC	?DecompressARGB@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressARGB
PUBLIC	?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ; CDXTCImage::DecodePixelFormat
PUBLIC	?Unextract@CDXTCImage@@QAEXPAEHHH@Z		; CDXTCImage::Unextract
PUBLIC	??_GCDXTCImage@@UAEPAXI@Z			; CDXTCImage::`scalar deleting destructor'
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_7CDXTCImage@@6B@				; CDXTCImage::`vftable'
PUBLIC	??_C@_04LFFPHNGG@?4DDS@				; `string'
PUBLIC	??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@ ; `string'
PUBLIC	??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@ ; `string'
PUBLIC	??_C@_07FBMAHCAD@?9premul@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@ ; `string'
PUBLIC	??_C@_04DHPPFAPI@DXT1@				; `string'
PUBLIC	??_C@_04BMNCADDL@DXT2@				; `string'
PUBLIC	??_C@_04FMJDCHK@DXT3@				; `string'
PUBLIC	??_C@_04EKIIKELN@DXT4@				; `string'
PUBLIC	??_C@_04FDJDJFPM@DXT5@				; `string'
PUBLIC	??_C@_0P@NBMDABNO@Format?5Unknown@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CDXTCImage@@6B@				; CDXTCImage::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDXTCImage@@@8				; CDXTCImage `RTTI Type Descriptor'
PUBLIC	??_R3CDXTCImage@@8				; CDXTCImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDXTCImage@@8				; CDXTCImage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDXTCImage@@8			; CDXTCImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@00000006000000040000000200000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_strstr:PROC
EXTRN	_strncpy:PROC
EXTRN	__strupr:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Create@CMappedFile@@QAEHPBDPAPBXHH@Z:PROC	; CMappedFile::Create
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	??_ECDXTCImage@@UAEPAXI@Z:PROC			; CDXTCImage::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
_BSS	SEGMENT
?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA DB 0105H DUP (?) ; `CDXTCImage::LoadFromFile'::`2'::fileupper
_BSS	ENDS
_BSS	SEGMENT
?gBits@@3PAY03EA DB 010H DUP (?)			; gBits
?gAlphas@@3PAGA DW 08H DUP (?)				; gAlphas
?gACol@@3PAY03UColor8888@@A DD 010H DUP (?)		; gACol
_BSS	ENDS
;	COMDAT __xmm@00000006000000040000000200000000
CONST	SEGMENT
__xmm@00000006000000040000000200000000 DB 00H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 04H, 00H, 00H, 00H, 06H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CDXTCImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDXTCImage@@8 DD FLAT:??_R0?AVCDXTCImage@@@8 ; CDXTCImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R2CDXTCImage@@8
rdata$r	SEGMENT
??_R2CDXTCImage@@8 DD FLAT:??_R1A@?0A@EA@CDXTCImage@@8	; CDXTCImage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDXTCImage@@8
rdata$r	SEGMENT
??_R3CDXTCImage@@8 DD 00H				; CDXTCImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDXTCImage@@@8
data$rs	SEGMENT
??_R0?AVCDXTCImage@@@8 DD FLAT:??_7type_info@@6B@	; CDXTCImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDXTCImage@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDXTCImage@@6B@
rdata$r	SEGMENT
??_R4CDXTCImage@@6B@ DD 00H				; CDXTCImage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDXTCImage@@@8
	DD	FLAT:??_R3CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NBMDABNO@Format?5Unknown@
CONST	SEGMENT
??_C@_0P@NBMDABNO@Format?5Unknown@ DB 'Format Unknown', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FDJDJFPM@DXT5@
CONST	SEGMENT
??_C@_04FDJDJFPM@DXT5@ DB 'DXT5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKIIKELN@DXT4@
CONST	SEGMENT
??_C@_04EKIIKELN@DXT4@ DB 'DXT4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMJDCHK@DXT3@
CONST	SEGMENT
??_C@_04FMJDCHK@DXT3@ DB 'DXT3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BMNCADDL@DXT2@
CONST	SEGMENT
??_C@_04BMNCADDL@DXT2@ DB 'DXT2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHPPFAPI@DXT1@
CONST	SEGMENT
??_C@_04DHPPFAPI@DXT1@ DB 'DXT1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@
CONST	SEGMENT
??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@ DB 'ARGB-%d%d%d%d%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBMAHCAD@?9premul@
CONST	SEGMENT
??_C@_07FBMAHCAD@?9premul@ DB '-premul', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@ DB 'Yo'
	DB	'ur logic is jacked! bits == 0x%x', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@ DB 'Ca'
	DB	'n''t open file for reading! [%s]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@
CONST	SEGMENT
??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@ DB 'Unknown file f'
	DB	'ormat encountered! [%s]', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFFPHNGG@?4DDS@
CONST	SEGMENT
??_C@_04LFFPHNGG@?4DDS@ DB '.DDS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CDXTCImage@@6B@
CONST	SEGMENT
??_7CDXTCImage@@6B@ DD FLAT:??_R4CDXTCImage@@6B@	; CDXTCImage::`vftable'
	DD	FLAT:??_ECDXTCImage@@UAEPAXI@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z$0
__ehfuncinfo$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CDXTCImage@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 3833 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3834 :     auto _FirstPtr              = _To_address(_First);
; 3835 :     auto _LastPtr               = _To_address(_Last);
; 3836 :     auto _DestPtr               = _To_address(_Dest);
; 3837 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 3838 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 3839 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 3840 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 3841 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3842 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 3843 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 3844 :     } else {
; 3845 :         return _Dest + (_LastPtr - _FirstPtr);
; 3846 :     }
; 3847 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 127  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 131  :         _Throw_bad_array_new_length(); // add overflow
; 132  :     }
; 133  : 
; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 138  : 
; 139  : #ifdef _DEBUG
; 140  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 141  : #endif // _DEBUG
; 142  :     return _Ptr;
; 143  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 1878 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1879 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1880 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1881 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 1882 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1883 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -4					; size = 4
tv435 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1574 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1575 :         if (_Newsize > max_size()) {

  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00012	0f 87 cb 00 00
	00		 ja	 $LN72@Resize_rea

; 1577 :         }
; 1578 : 
; 1579 :         auto& _Al         = _Getal();
; 1580 :         auto& _My_data    = _Mypair._Myval2;
; 1581 :         pointer& _Myfirst = _My_data._Myfirst;
; 1582 :         pointer& _Mylast  = _My_data._Mylast;
; 1583 : 
; 1584 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 2029 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0001b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1577 :         }
; 1578 : 
; 1579 :         auto& _Al         = _Getal();
; 1580 :         auto& _My_data    = _Mypair._Myval2;
; 1581 :         pointer& _Myfirst = _My_data._Myfirst;
; 1582 :         pointer& _Mylast  = _My_data._Mylast;
; 1583 : 
; 1584 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00020	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00022	89 4d fc	 mov	 DWORD PTR __Oldsize$1$[ebp], ecx

; 1942 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00025	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00028	2b 0f		 sub	 ecx, DWORD PTR [edi]

; 2029 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0002a	8b d1		 mov	 edx, ecx
  0002c	d1 ea		 shr	 edx, 1
  0002e	2b c2		 sub	 eax, edx
  00030	3b c8		 cmp	 ecx, eax
  00032	76 12		 jbe	 SHORT $LN10@Resize_rea

; 2030 :             return _Max; // geometric growth would overflow

  00034	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0003f	83 c4 04	 add	 esp, 4
  00042	8b d8		 mov	 ebx, eax
  00044	eb 30		 jmp	 SHORT $LN17@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2033 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00046	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]

; 2034 : 
; 2035 :         if (_Geometric < _Newsize) {

  00049	3b f3		 cmp	 esi, ebx
  0004b	0f 42 f3	 cmovb	 esi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0004e	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00054	72 0d		 jb	 SHORT $LN18@Resize_rea

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b d8		 mov	 ebx, eax
  00061	eb 13		 jmp	 SHORT $LN17@Resize_rea
$LN18@Resize_rea:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  00063	85 f6		 test	 esi, esi
  00065	74 0d		 je	 SHORT $LN19@Resize_rea

; 77   :         return ::operator new(_Bytes);

  00067	56		 push	 esi
  00068	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006d	83 c4 04	 add	 esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

  00070	8b d8		 mov	 ebx, eax
  00072	eb 02		 jmp	 SHORT $LN17@Resize_rea
$LN19@Resize_rea:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  00074	33 db		 xor	 ebx, ebx
$LN17@Resize_rea:

; 1896 :             _Zero_range(_PFirst, _PFirst + _Count);

  00076	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00079	03 c3		 add	 eax, ebx
  0007b	50		 push	 eax
  0007c	89 45 08	 mov	 DWORD PTR tv435[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1588 :         const pointer _Appended_first = _Newvec + _Oldsize;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  00082	03 c3		 add	 eax, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1896 :             _Zero_range(_PFirst, _PFirst + _Count);

  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>

; 1800 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  0008a	53		 push	 ebx
  0008b	ff 77 04	 push	 DWORD PTR [edi+4]
  0008e	ff 37		 push	 DWORD PTR [edi]
  00090	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_memmove<unsigned char *,unsigned char *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2086 :         if (_Myfirst) { // destroy and deallocate old array

  00095	8b 07		 mov	 eax, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1800 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00097	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2086 :         if (_Myfirst) { // destroy and deallocate old array

  0009a	85 c0		 test	 eax, eax
  0009c	74 29		 je	 SHORT $LN54@Resize_rea

; 2087 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2088 :             _ASAN_VECTOR_REMOVE;
; 2089 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0009e	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000a1	2b c8		 sub	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000a3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000a9	72 12		 jb	 SHORT $LN64@Resize_rea

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ab	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000ae	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000b1	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b3	83 c0 fc	 add	 eax, -4			; fffffffcH
  000b6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000b9	77 23		 ja	 SHORT $LN61@Resize_rea

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000bb	8b c2		 mov	 eax, edx
$LN64@Resize_rea:

; 255  :         ::operator delete(_Ptr, _Bytes);

  000bd	51		 push	 ecx
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000c4	83 c4 08	 add	 esp, 8
$LN54@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2093 :         _Mylast  = _Newvec + _Newsize;

  000c7	8b 45 08	 mov	 eax, DWORD PTR tv435[ebp]
  000ca	89 1f		 mov	 DWORD PTR [edi], ebx
  000cc	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2094 :         _Myend   = _Newvec + _Newcapacity;

  000cf	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  000d2	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1589 :         pointer _Appended_last        = _Appended_first;
; 1590 : 
; 1591 :         _TRY_BEGIN
; 1592 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1593 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1594 :         } else {
; 1595 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1596 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);
; 1597 :         }
; 1598 : 
; 1599 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1600 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 1601 :         } else {
; 1602 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1603 :         }
; 1604 :         _CATCH_ALL
; 1605 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1606 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1607 :         _RERAISE;
; 1608 :         _CATCH_END
; 1609 : 
; 1610 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1611 :     }

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 08 00	 ret	 8
$LN61@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000de	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN72@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1576 :             _Xlength();

  000e3	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN70@Resize_rea:
  000e8	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?GetNumberOfBits@@YAGK@Z
_TEXT	SEGMENT
_dwMask$ = 8						; size = 4
?GetNumberOfBits@@YAGK@Z PROC				; GetNumberOfBits, COMDAT

; 918  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 919  : 	WORD wBits;
; 920  : 	for (wBits = 0; dwMask; wBits++)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _dwMask$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 0c		 je	 SHORT $LN3@GetNumberO
  0000c	0f 1f 40 00	 npad	 4
$LL4@GetNumberO:

; 921  : 	{
; 922  : 		dwMask = (dwMask & (dwMask - 1));

  00010	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  00013	40		 inc	 eax
  00014	23 ca		 and	 ecx, edx
  00016	75 f8		 jne	 SHORT $LL4@GetNumberO
$LN3@GetNumberO:

; 923  : 	}
; 924  : 
; 925  : 	return wBits;
; 926  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?GetNumberOfBits@@YAGK@Z ENDP				; GetNumberOfBits
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDXTCImage@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDXTCImage@@UAEPAXI@Z PROC				; CDXTCImage::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDXTCImage@@UAE@XZ	; CDXTCImage::~CDXTCImage
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 28 01 00 00	 push	 296			; 00000128H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCDXTCImage@@UAEPAXI@Z ENDP				; CDXTCImage::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?Unextract@CDXTCImage@@QAEXPAEHHH@Z
_TEXT	SEGMENT
_xblocks$1$ = -4					; size = 4
_pbDest$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_yblocks$1$ = 20					; size = 4
_iPitch$ = 20						; size = 4
?Unextract@CDXTCImage@@QAEXPAEHHH@Z PROC		; CDXTCImage::Unextract, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi

; 306  : 	if (!m_pbCompBufferByLevels[0])

  00008	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0000b	85 f6		 test	 esi, esi
  0000d	74 5a		 je	 SHORT $LN3@Unextract

; 307  : 	{
; 308  : 		return;
; 309  : 	}
; 310  : 
; 311  : 	DXTColBlock * pBlock;
; 312  : 	BYTE * pPos = (BYTE *) &m_pbCompBufferByLevels[0][0];
; 313  : 	int xblocks = m_nWidth / 4;

  0000f	57		 push	 edi
  00010	8b bb 00 01 00
	00		 mov	 edi, DWORD PTR [ebx+256]
  00016	8b c7		 mov	 eax, edi
  00018	99		 cdq
  00019	83 e2 03	 and	 edx, 3
  0001c	03 c2		 add	 eax, edx
  0001e	c1 f8 02	 sar	 eax, 2
  00021	89 45 fc	 mov	 DWORD PTR _xblocks$1$[ebp], eax

; 314  : 	int yblocks = (m_nHeight / 4) * ((iPitch / m_nWidth) / 2);

  00024	8b 45 14	 mov	 eax, DWORD PTR _iPitch$[ebp]
  00027	99		 cdq
  00028	f7 ff		 idiv	 edi
  0002a	99		 cdq
  0002b	2b c2		 sub	 eax, edx
  0002d	8b c8		 mov	 ecx, eax
  0002f	8b 83 04 01 00
	00		 mov	 eax, DWORD PTR [ebx+260]
  00035	99		 cdq
  00036	83 e2 03	 and	 edx, 3
  00039	d1 f9		 sar	 ecx, 1
  0003b	03 c2		 add	 eax, edx
  0003d	c1 f8 02	 sar	 eax, 2
  00040	0f af c8	 imul	 ecx, eax
  00043	89 4d 14	 mov	 DWORD PTR _yblocks$1$[ebp], ecx

; 315  : 
; 316  : 	for (int y = 0; y < yblocks; ++y)

  00046	85 c9		 test	 ecx, ecx
  00048	7e 1e		 jle	 SHORT $LN11@Unextract

; 307  : 	{
; 308  : 		return;
; 309  : 	}
; 310  : 
; 311  : 	DXTColBlock * pBlock;
; 312  : 	BYTE * pPos = (BYTE *) &m_pbCompBufferByLevels[0][0];
; 313  : 	int xblocks = m_nWidth / 4;

  0004a	8b 7d fc	 mov	 edi, DWORD PTR _xblocks$1$[ebp]
  0004d	8b 5d 08	 mov	 ebx, DWORD PTR _pbDest$[ebp]
  00050	c1 e7 03	 shl	 edi, 3
$LL4@Unextract:

; 317  : 	{
; 318  : 		pBlock = (DXTColBlock*) (pPos + y * xblocks * 8);
; 319  : 
; 320  : 		memcpy(pbDest, pBlock, xblocks * 8);

  00053	57		 push	 edi
  00054	56		 push	 esi
  00055	53		 push	 ebx
  00056	e8 00 00 00 00	 call	 _memcpy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 321  : 		pbDest += xblocks * 8;

  0005e	03 df		 add	 ebx, edi
  00060	03 f7		 add	 esi, edi
  00062	83 6d 14 01	 sub	 DWORD PTR _yblocks$1$[ebp], 1
  00066	75 eb		 jne	 SHORT $LL4@Unextract
$LN11@Unextract:
  00068	5f		 pop	 edi
$LN3@Unextract:
  00069	5e		 pop	 esi

; 322  : 	}
; 323  : 
; 324  : 	/*
; 325  : 	for (int y = 0; y < iHeight; ++y)
; 326  : 	{
; 327  : 		memcpy(pbDest, &m_pbCompBufferByLevels[0][0] + y*iWidth, iWidth);
; 328  : 		pbDest += iWidth;
; 329  : 	}
; 330  : 	*/
; 331  : }

  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 10 00	 ret	 16			; 00000010H
?Unextract@CDXTCImage@@QAEXPAEHHH@Z ENDP		; CDXTCImage::Unextract
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z
_TEXT	SEGMENT
_strPixelFormat$ = 8					; size = 4
_pxddpf$ = 12						; size = 4
?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z PROC ; CDXTCImage::DecodePixelFormat, COMDAT
; _this$ = ecx

; 935  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 936  : 	switch (pxddpf->dwFourCC)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _pxddpf$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000d	3d 44 58 54 33	 cmp	 eax, 861165636		; 33545844H
  00012	0f 87 f5 00 00
	00		 ja	 $LN12@DecodePixe
  00018	0f 84 cd 00 00
	00		 je	 $LN7@DecodePixe
  0001e	85 c0		 test	 eax, eax
  00020	74 56		 je	 SHORT $LN4@DecodePixe
  00022	3d 44 58 54 31	 cmp	 eax, 827611204		; 31545844H
  00027	74 2d		 je	 SHORT $LN5@DecodePixe
  00029	3d 44 58 54 32	 cmp	 eax, 844388420		; 32545844H
  0002e	0f 85 e7 00 00
	00		 jne	 $LN10@DecodePixe

; 954  : 		m_CompFormat = PF_DXT1;
; 955  : 		break;
; 956  : 
; 957  : 	case MAKEFOURCC('D', 'X', 'T', '2'):
; 958  : 		strncpy(strPixelFormat, "DXT2", 31);

  00034	6a 1f		 push	 31			; 0000001fH
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_04BMNCADDL@DXT2@
  0003b	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  0003e	e8 00 00 00 00	 call	 _strncpy

; 980  : 		break;
; 981  : 	}
; 982  : }

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c7 86 ec 00 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+236], 2
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN5@DecodePixe:

; 949  : 	}
; 950  : 	break;
; 951  : 
; 952  : 	case MAKEFOURCC('D', 'X', 'T', '1'):
; 953  : 		strncpy(strPixelFormat, "DXT1", 31);

  00056	6a 1f		 push	 31			; 0000001fH
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_04DHPPFAPI@DXT1@
  0005d	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00060	e8 00 00 00 00	 call	 _strncpy

; 980  : 		break;
; 981  : 	}
; 982  : }

  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	c7 86 ec 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+236], 1
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8
$LN4@DecodePixe:

; 937  : 	{
; 938  : 	case 0:
; 939  : 	{
; 940  : 		// This dds texture isn't compressed so write out ARGB format
; 941  : 		WORD a = GetNumberOfBits(pxddpf->dwRGBAlphaBitMask);
; 942  : 		WORD r = GetNumberOfBits(pxddpf->dwRBitMask);
; 943  : 		WORD g = GetNumberOfBits(pxddpf->dwGBitMask);
; 944  : 		WORD b = GetNumberOfBits(pxddpf->dwBBitMask);
; 945  : 
; 946  : 		_snprintf(strPixelFormat, 31, "ARGB-%d%d%d%d%s", a, r, g, b,

  00078	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  0007b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_00CNPNBAHC@@
  00080	f7 c1 00 80 00
	00		 test	 ecx, 32768		; 00008000H
  00086	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07FBMAHCAD@?9premul@
  0008b	0f 44 c2	 cmove	 eax, edx
  0008e	50		 push	 eax
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  00095	83 c4 04	 add	 esp, 4
  00098	0f b7 c0	 movzx	 eax, ax
  0009b	50		 push	 eax
  0009c	ff 77 14	 push	 DWORD PTR [edi+20]
  0009f	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  000a4	83 c4 04	 add	 esp, 4
  000a7	0f b7 c0	 movzx	 eax, ax
  000aa	50		 push	 eax
  000ab	ff 77 10	 push	 DWORD PTR [edi+16]
  000ae	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  000b3	83 c4 04	 add	 esp, 4
  000b6	0f b7 c0	 movzx	 eax, ax
  000b9	50		 push	 eax
  000ba	ff 77 1c	 push	 DWORD PTR [edi+28]
  000bd	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  000c2	83 c4 04	 add	 esp, 4
  000c5	0f b7 c0	 movzx	 eax, ax
  000c8	50		 push	 eax
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@
  000ce	6a 1f		 push	 31			; 0000001fH
  000d0	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  000d3	e8 00 00 00 00	 call	 __snprintf
  000d8	83 c4 20	 add	 esp, 32			; 00000020H

; 947  : 				  pxddpf->dwBBitMask & DDPF_ALPHAPREMULT ? "-premul" : "");
; 948  : 		m_CompFormat = PF_ARGB;

  000db	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
  000e5	5f		 pop	 edi

; 980  : 		break;
; 981  : 	}
; 982  : }

  000e6	5e		 pop	 esi
  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN7@DecodePixe:

; 959  : 		m_CompFormat = PF_DXT2;
; 960  : 		break;
; 961  : 
; 962  : 	case MAKEFOURCC('D', 'X', 'T', '3'):
; 963  : 		strncpy(strPixelFormat, "DXT3", 31);

  000eb	6a 1f		 push	 31			; 0000001fH
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_04FMJDCHK@DXT3@
  000f2	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  000f5	e8 00 00 00 00	 call	 _strncpy

; 980  : 		break;
; 981  : 	}
; 982  : }

  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fd	c7 86 ec 00 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+236], 3
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5d		 pop	 ebp
  0010a	c2 08 00	 ret	 8
$LN12@DecodePixe:

; 936  : 	switch (pxddpf->dwFourCC)

  0010d	3d 44 58 54 34	 cmp	 eax, 877942852		; 34545844H
  00112	74 62		 je	 SHORT $LN8@DecodePixe
  00114	3d 44 58 54 35	 cmp	 eax, 894720068		; 35545844H
  00119	74 39		 je	 SHORT $LN9@DecodePixe
$LN10@DecodePixe:

; 974  : 		m_CompFormat = PF_DXT5;
; 975  : 		break;
; 976  : 
; 977  : 	default:
; 978  : 		strcpy(strPixelFormat, "Format Unknown");

  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _strPixelFormat$[ebp]
  0011e	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0P@NBMDABNO@Format?5Unknown@
  00126	5f		 pop	 edi
  00127	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0012b	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0P@NBMDABNO@Format?5Unknown@+8
  00130	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00133	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0P@NBMDABNO@Format?5Unknown@+12
  00139	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
  0013d	a0 0e 00 00 00	 mov	 al, BYTE PTR ??_C@_0P@NBMDABNO@Format?5Unknown@+14
  00142	88 41 0e	 mov	 BYTE PTR [ecx+14], al

; 979  : 		m_CompFormat = PF_UNKNOWN;

  00145	c7 86 ec 00 00
	00 06 00 00 00	 mov	 DWORD PTR [esi+236], 6

; 980  : 		break;
; 981  : 	}
; 982  : }

  0014f	5e		 pop	 esi
  00150	5d		 pop	 ebp
  00151	c2 08 00	 ret	 8
$LN9@DecodePixe:

; 969  : 		m_CompFormat = PF_DXT4;
; 970  : 		break;
; 971  : 
; 972  : 	case MAKEFOURCC('D', 'X', 'T', '5'):
; 973  : 		strncpy(strPixelFormat, "DXT5", 31);

  00154	6a 1f		 push	 31			; 0000001fH
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_04FDJDJFPM@DXT5@
  0015b	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  0015e	e8 00 00 00 00	 call	 _strncpy

; 980  : 		break;
; 981  : 	}
; 982  : }

  00163	83 c4 0c	 add	 esp, 12			; 0000000cH
  00166	c7 86 ec 00 00
	00 05 00 00 00	 mov	 DWORD PTR [esi+236], 5
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5d		 pop	 ebp
  00173	c2 08 00	 ret	 8
$LN8@DecodePixe:

; 964  : 		m_CompFormat = PF_DXT3;
; 965  : 		break;
; 966  : 
; 967  : 	case MAKEFOURCC('D', 'X', 'T', '4'):
; 968  : 		strncpy(strPixelFormat, "DXT4", 31);

  00176	6a 1f		 push	 31			; 0000001fH
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_04EKIIKELN@DXT4@
  0017d	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00180	e8 00 00 00 00	 call	 _strncpy

; 980  : 		break;
; 981  : 	}
; 982  : }

  00185	83 c4 0c	 add	 esp, 12			; 0000000cH
  00188	c7 86 ec 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+236], 4
  00192	5f		 pop	 edi
  00193	5e		 pop	 esi
  00194	5d		 pop	 ebp
  00195	c2 08 00	 ret	 8
?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ENDP ; CDXTCImage::DecodePixelFormat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressARGB@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressARGB@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressARGB, COMDAT
; _this$ = ecx

; 874  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 	UINT lPitch = m_lPitch >> (level * 2);

  00003	8b 55 08	 mov	 edx, DWORD PTR _level$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  0000c	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00012	d3 f8		 sar	 eax, cl

; 876  : 	memcpy(pdwDest, &m_bCompVector[level][0], lPitch);

  00014	50		 push	 eax
  00015	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00018	ff 74 86 34	 push	 DWORD PTR [esi+eax*4+52]
  0001c	ff 75 0c	 push	 DWORD PTR _pdwDest$[ebp]
  0001f	e8 00 00 00 00	 call	 _memcpy
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	5e		 pop	 esi

; 877  : }

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?DecompressARGB@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressARGB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
tv2480 = -132						; size = 4
tv2481 = -128						; size = 4
_alphazero$1$ = -124					; size = 4
tv2523 = -120						; size = 4
_yblocks$1$ = -116					; size = 4
_pdwDest$GSCopy$1$ = -112				; size = 4
_pPos$1$ = -108						; size = 4
_xblocks$1$ = -104					; size = 4
tv2532 = -100						; size = 4
_pBlock$1$ = -96					; size = 4
_nWidth$1$ = -92					; size = 4
_pAlphaBlock$1$ = -88					; size = 4
tv2537 = -84						; size = 4
tv2526 = -80						; size = 4
tv2343 = -76						; size = 4
tv2483 = -72						; size = 4
_col_1$ = -68						; size = 4
tv2545 = -64						; size = 4
tv2539 = -64						; size = 4
tv2346 = -60						; size = 4
_pImPos$1$ = -60					; size = 4
tv2348 = -56						; size = 4
_y$1$ = -56						; size = 4
_col_2$ = -52						; size = 4
_col_3$ = -48						; size = 4
_col_0$ = -44						; size = 4
tv2524 = -38						; size = 1
tv2527 = -37						; size = 1
_shift$1 = -36						; size = 16
_masks$2 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT5, COMDAT
; _this$ = ecx

; 799  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b d1		 mov	 edx, ecx

; 800  : 	int xblocks, yblocks;
; 801  : #ifdef DEBUG
; 802  : 	if ((ddsd.dwWidth % 4) != 0)
; 803  : 	{
; 804  : 		Tracef("****** warning width not div by 4! %d\n", ddsd.dwWidth);
; 805  : 	}
; 806  : 
; 807  : 	if ((ddsd.dwHeight % 4) != 0)
; 808  : 	{
; 809  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 810  : 	}
; 811  : 
; 812  : 	Tracef("end check\n");
; 813  : #endif
; 814  : 	UINT nWidth = m_nWidth >> level;
; 815  : 	UINT nHeight = m_nHeight >> level;
; 816  : 
; 817  : 	xblocks = nWidth / 4;
; 818  : 	yblocks = nHeight / 4;
; 819  : 
; 820  : 	int x, y;
; 821  : 
; 822  : 	DWORD * pBase = (DWORD *) pdwDest;
; 823  : 	WORD  * pPos = pPos = (WORD *) &m_bCompVector[level][0]; // pos in compressed data
; 824  : 	DWORD * pImPos;	// pos in decompressed data
; 825  : 
; 826  : 	DXTColBlock	* pBlock;
; 827  : 	DXTAlphaBlock3BitLinear * pAlphaBlock;
; 828  : 
; 829  : 	Color8888 col_0, col_1, col_2, col_3;
; 830  : 	WORD wrd;
; 831  : 
; 832  : 	// fill alphazero with appropriate value to zero out alpha when
; 833  : 	// alphazero is ANDed with the image color 32 bit DWORD:
; 834  : 	col_0.a = 0;
; 835  : 	col_0.r = col_0.g = col_0.b = 0xff;

  00015	c7 45 d4 ff ff
	ff 00		 mov	 DWORD PTR _col_0$[ebp], 16777215 ; 00ffffffH
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	8b b2 00 01 00
	00		 mov	 esi, DWORD PTR [edx+256]
  00027	8b 9a 04 01 00
	00		 mov	 ebx, DWORD PTR [edx+260]
  0002d	d3 fe		 sar	 esi, cl
  0002f	8b c6		 mov	 eax, esi
  00031	d3 fb		 sar	 ebx, cl
  00033	c1 e8 02	 shr	 eax, 2
  00036	89 45 98	 mov	 DWORD PTR _xblocks$1$[ebp], eax
  00039	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1952 :         return _My_data._Myfirst[_Pos];

  0003c	8b 4c 82 34	 mov	 ecx, DWORD PTR [edx+eax*4+52]
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 836  : 	DWORD alphazero = *((DWORD *) &col_0);

  00040	8b 45 d4	 mov	 eax, DWORD PTR _col_0$[ebp]
  00043	c1 eb 02	 shr	 ebx, 2
  00046	89 75 a4	 mov	 DWORD PTR _nWidth$1$[ebp], esi
  00049	89 5d 8c	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1952 :         return _My_data._Myfirst[_Pos];

  0004c	89 4d 94	 mov	 DWORD PTR _pPos$1$[ebp], ecx
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 836  : 	DWORD alphazero = *((DWORD *) &col_0);

  0004f	89 45 84	 mov	 DWORD PTR _alphazero$1$[ebp], eax
  00052	57		 push	 edi
  00053	8b 7d 0c	 mov	 edi, DWORD PTR _pdwDest$[ebp]
  00056	89 7d 90	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], edi

; 837  : 
; 838  : 	////////////////////////////////
; 839  : 	// Tracef("blocks: x: %d y: %d\n", xblocks, yblocks);
; 840  : 	for (y = 0; y < yblocks; ++y)

  00059	85 db		 test	 ebx, ebx
  0005b	0f 84 1a 05 00
	00		 je	 $LN3@Decompress

; 799  : {

  00061	8b 55 98	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
  00064	8b c6		 mov	 eax, esi
  00066	c1 e0 06	 shl	 eax, 6
  00069	8b f2		 mov	 esi, edx
  0006b	c1 e6 05	 shl	 esi, 5
  0006e	89 45 80	 mov	 DWORD PTR tv2481[ebp], eax
  00071	89 b5 7c ff ff
	ff		 mov	 DWORD PTR tv2480[ebp], esi
  00077	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@Decompress:

; 841  : 	{
; 842  : 		// 8 bytes per block
; 843  : 		// 1 block for alpha, 1 block for color
; 844  : 		pBlock = (DXTColBlock*) ((DWORD) (pPos + y * xblocks * 16));

  00080	8b f1		 mov	 esi, ecx

; 845  : 
; 846  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00082	85 d2		 test	 edx, edx
  00084	0f 84 d7 04 00
	00		 je	 $LN2@Decompress

; 463  : 	const int   shift[] = { 0, 2, 4, 6 };

  0008a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000

; 377  : 	col_0->a = 0xff;

  00091	c6 45 d7 ff	 mov	 BYTE PTR _col_0$[ebp+3], 255 ; 000000ffH

; 384  : 
; 385  : 	pCol = (Color565*) & (pBlock->col1);
; 386  : 	col_1->a = 0xff;

  00095	c6 45 bf ff	 mov	 BYTE PTR _col_1$[ebp+3], 255 ; 000000ffH

; 434  : 		col_2->r = (BYTE)wrd;
; 435  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);
; 436  : 		col_2->g = (BYTE)wrd;
; 437  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);
; 438  : 		col_2->b = (BYTE)wrd;
; 439  : 		col_2->a = 0xff;

  00099	c6 45 cf ff	 mov	 BYTE PTR _col_2$[ebp+3], 255 ; 000000ffH

; 462  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  0009d	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _masks$2[ebp], 3
  000a4	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+4], 12 ; 0000000cH
  000ab	c7 45 f4 30 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+8], 48 ; 00000030H
  000b2	c7 45 f8 c0 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+12], 192 ; 000000c0H

; 463  : 	const int   shift[] = { 0, 2, 4, 6 };

  000b9	0f 11 45 dc	 movups	 XMMWORD PTR _shift$1[ebp], xmm0

; 841  : 	{
; 842  : 		// 8 bytes per block
; 843  : 		// 1 block for alpha, 1 block for color
; 844  : 		pBlock = (DXTColBlock*) ((DWORD) (pPos + y * xblocks * 16));

  000bd	89 7d b8	 mov	 DWORD PTR tv2483[ebp], edi
  000c0	89 55 9c	 mov	 DWORD PTR tv2532[ebp], edx
$LL7@Decompress:

; 378  : 	col_0->r = pCol->nRed;

  000c3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c6	8b d9		 mov	 ebx, ecx

; 847  : 		{
; 848  : 			// inline
; 849  : 			// Get alpha block
; 850  : 			pAlphaBlock = (DXTAlphaBlock3BitLinear*) pBlock;

  000c8	89 75 a8	 mov	 DWORD PTR _pAlphaBlock$1$[ebp], esi

; 380  : 	col_0->g = pCol->nGreen;

  000cb	8b d1		 mov	 edx, ecx
  000cd	c1 ea 05	 shr	 edx, 5

; 851  : 
; 852  : 			// inline func:
; 853  : 			// Get color block & colors
; 854  : 			pBlock++;

  000d0	83 c6 08	 add	 esi, 8

; 381  : 	col_0->g <<= 2;

  000d3	c0 e2 02	 shl	 dl, 2

; 382  : 	col_0->b = pCol->nBlue;
; 383  : 	col_0->b <<= 3;

  000d6	8a c1		 mov	 al, cl
  000d8	89 55 b4	 mov	 DWORD PTR tv2343[ebp], edx
  000db	88 55 d5	 mov	 BYTE PTR _col_0$[ebp+1], dl
  000de	c0 e0 03	 shl	 al, 3
  000e1	88 45 da	 mov	 BYTE PTR tv2524[ebp], al
  000e4	88 45 d4	 mov	 BYTE PTR _col_0$[ebp], al

; 387  : 	col_1->r = pCol->nRed;

  000e7	8b 46 02	 mov	 eax, DWORD PTR [esi+2]
  000ea	8b d0		 mov	 edx, eax
  000ec	c1 ea 0b	 shr	 edx, 11			; 0000000bH

; 388  : 	col_1->r <<= 3;				// shift to full precision

  000ef	c0 e2 03	 shl	 dl, 3
  000f2	89 55 c4	 mov	 DWORD PTR tv2346[ebp], edx
  000f5	88 55 be	 mov	 BYTE PTR _col_1$[ebp+2], dl

; 389  : 	col_1->g = pCol->nGreen;

  000f8	8b d0		 mov	 edx, eax
  000fa	c1 ea 05	 shr	 edx, 5

; 390  : 	col_1->g <<= 2;

  000fd	c0 e2 02	 shl	 dl, 2
  00100	89 55 c8	 mov	 DWORD PTR tv2348[ebp], edx
  00103	88 55 bd	 mov	 BYTE PTR _col_1$[ebp+1], dl

; 391  : 	col_1->b = pCol->nBlue;
; 392  : 	col_1->b <<= 3;

  00106	8a d0		 mov	 dl, al
  00108	c0 e2 03	 shl	 dl, 3
  0010b	88 55 db	 mov	 BYTE PTR tv2527[ebp], dl
  0010e	88 55 bc	 mov	 BYTE PTR _col_1$[ebp], dl
  00111	8b 55 c4	 mov	 edx, DWORD PTR tv2346[ebp]

; 851  : 
; 852  : 			// inline func:
; 853  : 			// Get color block & colors
; 854  : 			pBlock++;

  00114	89 75 a0	 mov	 DWORD PTR _pBlock$1$[ebp], esi

; 392  : 	col_1->b <<= 3;

  00117	0f b6 f2	 movzx	 esi, dl
  0011a	8b 55 c8	 mov	 edx, DWORD PTR tv2348[ebp]
  0011d	0f b6 fa	 movzx	 edi, dl
  00120	0f b6 55 db	 movzx	 edx, BYTE PTR tv2527[ebp]
  00124	c1 eb 0b	 shr	 ebx, 11			; 0000000bH
  00127	c0 e3 03	 shl	 bl, 3

; 393  : 
; 394  : 	if (pBlock->col0 > pBlock->col1)

  0012a	66 3b c8	 cmp	 cx, ax
  0012d	89 55 c0	 mov	 DWORD PTR tv2545[ebp], edx
  00130	0f b6 d3	 movzx	 edx, bl
  00133	89 55 b0	 mov	 DWORD PTR tv2526[ebp], edx
  00136	8b 55 b4	 mov	 edx, DWORD PTR tv2343[ebp]
  00139	8b 45 b0	 mov	 eax, DWORD PTR tv2526[ebp]
  0013c	0f b6 d2	 movzx	 edx, dl
  0013f	89 55 ac	 mov	 DWORD PTR tv2537[ebp], edx
  00142	0f b6 55 da	 movzx	 edx, BYTE PTR tv2524[ebp]
  00146	88 5d d6	 mov	 BYTE PTR _col_0$[ebp+2], bl
  00149	89 55 88	 mov	 DWORD PTR tv2523[ebp], edx
  0014c	0f 86 86 00 00
	00		 jbe	 $LN10@Decompress

; 395  : 	{
; 396  : 		// Four-color block: derive the other two colors.
; 397  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 398  : 		// These two bit codes correspond to the 2-bit fields
; 399  : 		// stored in the 64-bit block.
; 400  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);

  00152	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]

; 401  : 		// no +1 for rounding
; 402  : 		// as bits have been shifted to 888
; 403  : 		col_2->r = (BYTE)wrd;
; 404  : 
; 405  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);
; 406  : 		col_2->g = (BYTE)wrd;
; 407  : 
; 408  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);
; 409  : 		col_2->b = (BYTE)wrd;
; 410  : 		col_2->a = 0xff;
; 411  : 
; 412  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);
; 413  : 		col_3->r = (BYTE)wrd;
; 414  : 
; 415  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);
; 416  : 		col_3->g = (BYTE)wrd;
; 417  : 
; 418  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);
; 419  : 		col_3->b = (BYTE)wrd;
; 420  : 		col_3->a = 0xff;

  00155	c6 45 d3 ff	 mov	 BYTE PTR _col_3$[ebp+3], 255 ; 000000ffH
  00159	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0015e	f7 e1		 mul	 ecx
  00160	8b 45 ac	 mov	 eax, DWORD PTR tv2537[ebp]
  00163	d1 ea		 shr	 edx, 1
  00165	88 55 ce	 mov	 BYTE PTR _col_2$[ebp+2], dl
  00168	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  0016b	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00170	f7 e1		 mul	 ecx
  00172	8b 45 c0	 mov	 eax, DWORD PTR tv2545[ebp]
  00175	8b 4d 88	 mov	 ecx, DWORD PTR tv2523[ebp]
  00178	d1 ea		 shr	 edx, 1
  0017a	88 55 cd	 mov	 BYTE PTR _col_2$[ebp+1], dl
  0017d	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00180	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00185	f7 e1		 mul	 ecx
  00187	8b 45 c4	 mov	 eax, DWORD PTR tv2346[ebp]
  0018a	0f b6 c8	 movzx	 ecx, al
  0018d	d1 ea		 shr	 edx, 1
  0018f	0f b6 c3	 movzx	 eax, bl
  00192	88 55 cc	 mov	 BYTE PTR _col_2$[ebp], dl
  00195	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00198	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0019d	f7 e1		 mul	 ecx
  0019f	8b 45 c8	 mov	 eax, DWORD PTR tv2348[ebp]
  001a2	0f b6 c8	 movzx	 ecx, al
  001a5	8b 45 b4	 mov	 eax, DWORD PTR tv2343[ebp]
  001a8	0f b6 c0	 movzx	 eax, al
  001ab	d1 ea		 shr	 edx, 1
  001ad	88 55 d2	 mov	 BYTE PTR _col_3$[ebp+2], dl
  001b0	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001b3	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001b8	f7 e1		 mul	 ecx
  001ba	0f b6 45 da	 movzx	 eax, BYTE PTR tv2524[ebp]
  001be	0f b6 4d db	 movzx	 ecx, BYTE PTR tv2527[ebp]
  001c2	d1 ea		 shr	 edx, 1
  001c4	88 55 d1	 mov	 BYTE PTR _col_3$[ebp+1], dl
  001c7	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001ca	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001cf	f7 e1		 mul	 ecx
  001d1	d1 ea		 shr	 edx, 1
  001d3	88 55 d0	 mov	 BYTE PTR _col_3$[ebp], dl

; 421  : 	}

  001d6	eb 29		 jmp	 SHORT $LN11@Decompress
$LN10@Decompress:

; 422  : 	else
; 423  : 	{
; 424  : 		// Three-color block: derive the other color.
; 425  : 		// 00 = color_0,  01 = color_1,  10 = color_2,
; 426  : 		// 11 = transparent.
; 427  : 		// These two bit codes correspond to the 2-bit fields
; 428  : 		// stored in the 64-bit block.
; 429  : 
; 430  : 		// explicit for each component, unlike some refrasts...
; 431  : 
; 432  : 		// Tracef("block has alpha\n");
; 433  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  001d8	03 c6		 add	 eax, esi

; 440  : 
; 441  : 		col_3->r = 0x00;		// random color to indicate alpha
; 442  : 		col_3->g = 0x00;

  001da	66 c7 45 d1 00
	00		 mov	 WORD PTR _col_3$[ebp+1], 0
  001e0	d1 e8		 shr	 eax, 1
  001e2	88 45 ce	 mov	 BYTE PTR _col_2$[ebp+2], al
  001e5	8b 45 ac	 mov	 eax, DWORD PTR tv2537[ebp]
  001e8	03 c7		 add	 eax, edi

; 443  : 		col_3->b = 0x00;

  001ea	c6 45 d0 00	 mov	 BYTE PTR _col_3$[ebp], 0
  001ee	d1 e8		 shr	 eax, 1
  001f0	88 45 cd	 mov	 BYTE PTR _col_2$[ebp+1], al
  001f3	8b 45 c0	 mov	 eax, DWORD PTR tv2545[ebp]
  001f6	03 c2		 add	 eax, edx

; 444  : 		col_3->a = 0x00;

  001f8	c6 45 d3 00	 mov	 BYTE PTR _col_3$[ebp+3], 0
  001fc	d1 e8		 shr	 eax, 1
  001fe	88 45 cc	 mov	 BYTE PTR _col_2$[ebp], al
$LN11@Decompress:

; 855  : 
; 856  : 			// Tracef("pBlock: 0x%.8x\n", pBlock);
; 857  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 858  : 
; 859  : 			// Decode the color block into the bitmap bits
; 860  : 			// inline func:
; 861  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 862  : 
; 863  : 			//DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);
; 864  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  00201	8b 55 b8	 mov	 edx, DWORD PTR tv2483[ebp]

; 466  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  00204	33 c0		 xor	 eax, eax
  00206	8b 75 d4	 mov	 esi, DWORD PTR _col_0$[ebp]
  00209	8b 7d d0	 mov	 edi, DWORD PTR _col_3$[ebp]

; 855  : 
; 856  : 			// Tracef("pBlock: 0x%.8x\n", pBlock);
; 857  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 858  : 
; 859  : 			// Decode the color block into the bitmap bits
; 860  : 			// inline func:
; 861  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 862  : 
; 863  : 			//DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);
; 864  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  0020c	89 55 c4	 mov	 DWORD PTR _pImPos$1$[ebp], edx

; 466  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  0020f	89 45 c8	 mov	 DWORD PTR _y$1$[ebp], eax
$LL16@Decompress:

; 467  : 	{
; 468  : 		// width * 4 bytes per pixel per line
; 469  : 		// each j dxtc row is 4 lines of pixels
; 470  : 
; 471  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 472  : 
; 473  : 		// n steps through pixels
; 474  : 		for (n = 0; n < 4; ++n)

  00212	33 db		 xor	 ebx, ebx
$LL19@Decompress:

; 475  : 		{
; 476  : 			bits = pColorBlock->row[y] & masks[n];

  00214	8b 4d a0	 mov	 ecx, DWORD PTR _pBlock$1$[ebp]
  00217	0f b6 4c 08 04	 movzx	 ecx, BYTE PTR [eax+ecx+4]
  0021c	8b 44 1d ec	 mov	 eax, DWORD PTR _masks$2[ebp+ebx]
  00220	23 c1		 and	 eax, ecx

; 477  : 			bits >>= shift[n];

  00222	8b 4c 1d dc	 mov	 ecx, DWORD PTR _shift$1[ebp+ebx]
  00226	d3 e8		 shr	 eax, cl

; 478  : 
; 479  : 			switch (bits)

  00228	83 f8 03	 cmp	 eax, 3
  0022b	77 1d		 ja	 SHORT $LN26@Decompress
  0022d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN91@Decompress[eax*4]
$LN22@Decompress:

; 480  : 			{
; 481  : 			case 0:
; 482  : 				*pImPos = *col_0;

  00234	89 32		 mov	 DWORD PTR [edx], esi

; 483  : 				pImPos++; // increment to next DWORD
; 484  : 				break;

  00236	eb 23		 jmp	 SHORT $LN17@Decompress
$LN23@Decompress:

; 485  : 
; 486  : 			case 1:
; 487  : 				*pImPos = *col_1;

  00238	8b 45 bc	 mov	 eax, DWORD PTR _col_1$[ebp]
  0023b	89 02		 mov	 DWORD PTR [edx], eax

; 488  : 				pImPos++;
; 489  : 				break;

  0023d	eb 1c		 jmp	 SHORT $LN17@Decompress
$LN24@Decompress:

; 490  : 
; 491  : 			case 2:
; 492  : 				*pImPos = *col_2;

  0023f	8b 45 cc	 mov	 eax, DWORD PTR _col_2$[ebp]
  00242	89 02		 mov	 DWORD PTR [edx], eax

; 493  : 				pImPos++;
; 494  : 				break;

  00244	eb 15		 jmp	 SHORT $LN17@Decompress
$LN25@Decompress:

; 495  : 
; 496  : 			case 3:
; 497  : 				*pImPos = *col_3;

  00246	89 3a		 mov	 DWORD PTR [edx], edi

; 498  : 				pImPos++;
; 499  : 				break;

  00248	eb 11		 jmp	 SHORT $LN17@Decompress
$LN26@Decompress:

; 500  : 
; 501  : 			default:
; 502  : 				Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  0024a	50		 push	 eax
  0024b	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  00250	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00255	8b 55 c4	 mov	 edx, DWORD PTR _pImPos$1$[ebp]
  00258	83 c4 08	 add	 esp, 8
$LN17@Decompress:

; 467  : 	{
; 468  : 		// width * 4 bytes per pixel per line
; 469  : 		// each j dxtc row is 4 lines of pixels
; 470  : 
; 471  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 472  : 
; 473  : 		// n steps through pixels
; 474  : 		for (n = 0; n < 4; ++n)

  0025b	8b 45 c8	 mov	 eax, DWORD PTR _y$1$[ebp]
  0025e	83 c2 04	 add	 edx, 4
  00261	83 c3 04	 add	 ebx, 4
  00264	89 55 c4	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  00267	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0026a	7c a8		 jl	 SHORT $LL19@Decompress

; 464  : 
; 465  : 	// r steps through lines in y
; 466  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  0026c	8b 4d a4	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  0026f	40		 inc	 eax
  00270	89 45 c8	 mov	 DWORD PTR _y$1$[ebp], eax
  00273	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00276	83 c2 f0	 add	 edx, -16		; fffffff0H
  00279	89 55 c4	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  0027c	83 f8 04	 cmp	 eax, 4
  0027f	7c 91		 jl	 SHORT $LL16@Decompress

; 567  : 	gAlphas[0] = pAlphaBlock->alpha0;

  00281	8b 4d a8	 mov	 ecx, DWORD PTR _pAlphaBlock$1$[ebp]

; 865  : 
; 866  : 			// Overwrite the previous alpha bits with the alpha block
; 867  : 			//  info
; 868  : 			DecodeAlpha3BitLinear(pImPos, pAlphaBlock, nWidth, alphazero);

  00284	8b 75 b8	 mov	 esi, DWORD PTR tv2483[ebp]

; 567  : 	gAlphas[0] = pAlphaBlock->alpha0;

  00287	8a 11		 mov	 dl, BYTE PTR [ecx]

; 568  : 	gAlphas[1] = pAlphaBlock->alpha1;

  00289	8a 49 01	 mov	 cl, BYTE PTR [ecx+1]
  0028c	0f b6 c2	 movzx	 eax, dl
  0028f	3a d1		 cmp	 dl, cl
  00291	0f b6 d9	 movzx	 ebx, cl
  00294	66 a3 00 00 00
	00		 mov	 WORD PTR ?gAlphas@@3PAGA, ax
  0029a	0f b6 c1	 movzx	 eax, cl
  0029d	89 5d c0	 mov	 DWORD PTR tv2539[ebp], ebx
  002a0	66 a3 02 00 00
	00		 mov	 WORD PTR ?gAlphas@@3PAGA+2, ax
  002a6	0f b6 f9	 movzx	 edi, cl

; 569  : 
; 570  : 	// 8-alpha or 6-alpha block?
; 571  : 	if (gAlphas[0] > gAlphas[1])

  002a9	8b 4d c0	 mov	 ecx, DWORD PTR tv2539[ebp]
  002ac	0f b6 c2	 movzx	 eax, dl
  002af	0f b6 da	 movzx	 ebx, dl
  002b2	0f 86 b0 00 00
	00		 jbe	 $LN41@Decompress

; 572  : 	{
; 573  : 		// 8-alpha block:  derive the other 6 alphas.
; 574  : 		// 000 = alpha_0, 001 = alpha_1, others are interpolated
; 575  : 		gAlphas[2] = (WORD) ((6 * gAlphas[0] +     gAlphas[1]) / 7);	// Bit code 010

  002b8	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  002bb	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  002be	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  002c3	f7 e1		 mul	 ecx

; 576  : 		gAlphas[3] = (WORD) ((5 * gAlphas[0] + 2 * gAlphas[1]) / 7);	// Bit code 011

  002c5	8d 04 9b	 lea	 eax, DWORD PTR [ebx+ebx*4]
  002c8	2b ca		 sub	 ecx, edx
  002ca	d1 e9		 shr	 ecx, 1
  002cc	03 ca		 add	 ecx, edx
  002ce	c1 e9 02	 shr	 ecx, 2
  002d1	66 89 0d 04 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+4, cx
  002d8	8d 0c 78	 lea	 ecx, DWORD PTR [eax+edi*2]
  002db	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  002e0	f7 e1		 mul	 ecx

; 577  : 		gAlphas[4] = (WORD) ((4 * gAlphas[0] + 3 * gAlphas[1]) / 7);	// Bit code 100

  002e2	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  002e5	2b ca		 sub	 ecx, edx
  002e7	d1 e9		 shr	 ecx, 1
  002e9	03 ca		 add	 ecx, edx
  002eb	c1 e9 02	 shr	 ecx, 2
  002ee	66 89 0d 06 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+6, cx
  002f5	8d 0c 98	 lea	 ecx, DWORD PTR [eax+ebx*4]
  002f8	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  002fd	f7 e1		 mul	 ecx

; 578  : 		gAlphas[5] = (WORD) ((3 * gAlphas[0] + 4 * gAlphas[1]) / 7);	// Bit code 101

  002ff	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00302	2b ca		 sub	 ecx, edx
  00304	d1 e9		 shr	 ecx, 1
  00306	03 ca		 add	 ecx, edx
  00308	c1 e9 02	 shr	 ecx, 2
  0030b	66 89 0d 08 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+8, cx
  00312	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00315	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  0031a	f7 e1		 mul	 ecx

; 579  : 		gAlphas[6] = (WORD) ((2 * gAlphas[0] + 5 * gAlphas[1]) / 7);	// Bit code 110

  0031c	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  0031f	2b ca		 sub	 ecx, edx
  00321	d1 e9		 shr	 ecx, 1
  00323	03 ca		 add	 ecx, edx
  00325	c1 e9 02	 shr	 ecx, 2
  00328	66 89 0d 0a 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+10, cx
  0032f	8d 0c 58	 lea	 ecx, DWORD PTR [eax+ebx*2]
  00332	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  00337	f7 e1		 mul	 ecx

; 580  : 		gAlphas[7] = (WORD) ((    gAlphas[0] + 6 * gAlphas[1]) / 7);	// Bit code 111

  00339	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0033c	2b ca		 sub	 ecx, edx
  0033e	d1 e9		 shr	 ecx, 1
  00340	03 ca		 add	 ecx, edx
  00342	c1 e9 02	 shr	 ecx, 2
  00345	66 89 0d 0c 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+12, cx
  0034c	8d 0c 43	 lea	 ecx, DWORD PTR [ebx+eax*2]
  0034f	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  00354	f7 e1		 mul	 ecx
  00356	2b ca		 sub	 ecx, edx
  00358	d1 e9		 shr	 ecx, 1
  0035a	03 ca		 add	 ecx, edx
  0035c	c1 e9 02	 shr	 ecx, 2
  0035f	66 89 0d 0e 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+14, cx

; 581  : 	}

  00366	eb 60		 jmp	 SHORT $LN42@Decompress
$LN41@Decompress:

; 582  : 	else
; 583  : 	{
; 584  : 		// 6-alpha block:  derive the other alphas.
; 585  : 		// 000 = alpha_0, 001 = alpha_1, others are interpolated
; 586  : 		gAlphas[2] = (WORD) ((4 * gAlphas[0] +     gAlphas[1]) / 5);	// Bit code 010

  00368	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]

; 587  : 		gAlphas[3] = (WORD) ((3 * gAlphas[0] + 2 * gAlphas[1]) / 5);	// Bit code 011
; 588  : 		gAlphas[4] = (WORD) ((2 * gAlphas[0] + 3 * gAlphas[1]) / 5);	// Bit code 100
; 589  : 		gAlphas[5] = (WORD) ((   gAlphas[0] + 4 * gAlphas[1]) / 5);		// Bit code 101
; 590  : 		gAlphas[6] = 0;													// Bit code 110

  0036b	c7 05 0c 00 00
	00 00 00 ff 00	 mov	 DWORD PTR ?gAlphas@@3PAGA+12, 16711680 ; 00ff0000H
  00375	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0037a	f7 e1		 mul	 ecx
  0037c	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  0037f	8d 0c 78	 lea	 ecx, DWORD PTR [eax+edi*2]
  00382	c1 ea 02	 shr	 edx, 2
  00385	66 89 15 04 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+4, dx
  0038c	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00391	f7 e1		 mul	 ecx
  00393	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00396	c1 ea 02	 shr	 edx, 2
  00399	8d 0c 58	 lea	 ecx, DWORD PTR [eax+ebx*2]
  0039c	66 89 15 06 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+6, dx
  003a3	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  003a8	f7 e1		 mul	 ecx
  003aa	8d 0c bb	 lea	 ecx, DWORD PTR [ebx+edi*4]
  003ad	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  003b2	c1 ea 02	 shr	 edx, 2
  003b5	66 89 15 08 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+8, dx
  003bc	f7 e1		 mul	 ecx
  003be	c1 ea 02	 shr	 edx, 2
  003c1	66 89 15 0a 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+10, dx
$LN42@Decompress:

; 591  : 		gAlphas[7] = 255;												// Bit code 111
; 592  : 	}
; 593  : 
; 594  : 	// Decode 3-bit fields into array of 16 BYTES with same value
; 595  : 
; 596  : 	// first two rows of 4 pixels each:
; 597  : 	// pRows = (Alpha3BitRows*) & (pAlphaBlock->stuff[0]);
; 598  : 	const DWORD mask = 0x00000007;		// bits = 00 00 01 11
; 599  : 	DWORD bits = *((DWORD*) & (pAlphaBlock->stuff[0]));

  003c8	8b 55 a8	 mov	 edx, DWORD PTR _pAlphaBlock$1$[ebp]
  003cb	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]

; 600  : 
; 601  : 	gBits[0][0] = (BYTE) (bits & mask);

  003ce	8a c1		 mov	 al, cl
  003d0	24 07		 and	 al, 7

; 602  : 	bits >>= 3;

  003d2	c1 e9 03	 shr	 ecx, 3
  003d5	a2 00 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA, al

; 603  : 	gBits[0][1] = (BYTE) (bits & mask);

  003da	8a c1		 mov	 al, cl
  003dc	24 07		 and	 al, 7

; 604  : 	bits >>= 3;

  003de	c1 e9 03	 shr	 ecx, 3
  003e1	a2 01 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+1, al

; 605  : 	gBits[0][2] = (BYTE) (bits & mask);

  003e6	8a c1		 mov	 al, cl
  003e8	24 07		 and	 al, 7

; 606  : 	bits >>= 3;

  003ea	c1 e9 03	 shr	 ecx, 3
  003ed	a2 02 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+2, al

; 607  : 	gBits[0][3] = (BYTE) (bits & mask);

  003f2	8a c1		 mov	 al, cl
  003f4	24 07		 and	 al, 7

; 608  : 	bits >>= 3;

  003f6	c1 e9 03	 shr	 ecx, 3
  003f9	a2 03 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+3, al

; 609  : 	gBits[1][0] = (BYTE) (bits & mask);

  003fe	8a c1		 mov	 al, cl
  00400	24 07		 and	 al, 7

; 610  : 	bits >>= 3;

  00402	c1 e9 03	 shr	 ecx, 3
  00405	a2 04 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+4, al

; 611  : 	gBits[1][1] = (BYTE) (bits & mask);

  0040a	8a c1		 mov	 al, cl
  0040c	24 07		 and	 al, 7

; 612  : 	bits >>= 3;

  0040e	c1 e9 03	 shr	 ecx, 3
  00411	a2 05 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+5, al

; 613  : 	gBits[1][2] = (BYTE) (bits & mask);

  00416	8a c1		 mov	 al, cl
  00418	24 07		 and	 al, 7

; 614  : 	bits >>= 3;

  0041a	c1 e9 03	 shr	 ecx, 3
  0041d	a2 06 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+6, al

; 615  : 	gBits[1][3] = (BYTE) (bits & mask);

  00422	80 e1 07	 and	 cl, 7
  00425	88 0d 07 00 00
	00		 mov	 BYTE PTR ?gBits@@3PAY03EA+7, cl

; 616  : 
; 617  : 	// now for last two rows:
; 618  : 	bits = *((DWORD*) & (pAlphaBlock->stuff[3]));		// last 3 bytes

  0042b	8b 4a 05	 mov	 ecx, DWORD PTR [edx+5]

; 619  : 
; 620  : 	gBits[2][0] = (BYTE) (bits & mask);

  0042e	8a c1		 mov	 al, cl
  00430	24 07		 and	 al, 7

; 621  : 	bits >>= 3;

  00432	c1 e9 03	 shr	 ecx, 3
  00435	a2 08 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+8, al
  0043a	ba 07 00 00 00	 mov	 edx, OFFSET ?gACol@@3PAY03UColor8888@@A+7

; 622  : 	gBits[2][1] = (BYTE) (bits & mask);

  0043f	8a c1		 mov	 al, cl

; 623  : 	bits >>= 3;

  00441	c1 e9 03	 shr	 ecx, 3
  00444	24 07		 and	 al, 7
  00446	a2 09 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+9, al

; 624  : 	gBits[2][2] = (BYTE) (bits & mask);

  0044b	8a c1		 mov	 al, cl
  0044d	24 07		 and	 al, 7

; 625  : 	bits >>= 3;

  0044f	c1 e9 03	 shr	 ecx, 3
  00452	a2 0a 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+10, al

; 626  : 	gBits[2][3] = (BYTE) (bits & mask);

  00457	8a c1		 mov	 al, cl
  00459	24 07		 and	 al, 7

; 627  : 	bits >>= 3;

  0045b	c1 e9 03	 shr	 ecx, 3
  0045e	a2 0b 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+11, al

; 628  : 	gBits[3][0] = (BYTE) (bits & mask);

  00463	8a c1		 mov	 al, cl
  00465	24 07		 and	 al, 7

; 629  : 	bits >>= 3;

  00467	c1 e9 03	 shr	 ecx, 3
  0046a	a2 0c 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+12, al

; 630  : 	gBits[3][1] = (BYTE) (bits & mask);

  0046f	8a c1		 mov	 al, cl
  00471	24 07		 and	 al, 7

; 631  : 	bits >>= 3;

  00473	c1 e9 03	 shr	 ecx, 3
  00476	a2 0d 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+13, al

; 632  : 	gBits[3][2] = (BYTE) (bits & mask);

  0047b	8a c1		 mov	 al, cl

; 633  : 	bits >>= 3;

  0047d	c1 e9 03	 shr	 ecx, 3
  00480	24 07		 and	 al, 7

; 634  : 	gBits[3][3] = (BYTE) (bits & mask);

  00482	80 e1 07	 and	 cl, 7
  00485	a2 0e 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+14, al
  0048a	88 0d 0f 00 00
	00		 mov	 BYTE PTR ?gBits@@3PAY03EA+15, cl
  00490	b9 01 00 00 00	 mov	 ecx, OFFSET ?gBits@@3PAY03EA+1
  00495	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL31@Decompress:

; 635  : 
; 636  : 	// decode the codes into alpha values
; 637  : 	int row, pix;
; 638  : 
; 639  : 	for (row = 0; row < 4; ++row)
; 640  : 	{
; 641  : 		for (pix = 0; pix < 4; ++pix)
; 642  : 		{
; 643  : 			gACol[row][pix].a = (BYTE) gAlphas[gBits[row][pix]];

  004a0	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  004a4	8d 52 10	 lea	 edx, DWORD PTR [edx+16]
  004a7	0f b6 04 45 00
	00 00 00	 movzx	 eax, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  004af	88 42 ec	 mov	 BYTE PTR [edx-20], al
  004b2	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  004b5	0f b6 04 45 00
	00 00 00	 movzx	 eax, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  004bd	88 42 f0	 mov	 BYTE PTR [edx-16], al
  004c0	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  004c4	0f b6 04 45 00
	00 00 00	 movzx	 eax, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  004cc	88 42 f4	 mov	 BYTE PTR [edx-12], al
  004cf	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]
  004d3	83 c1 04	 add	 ecx, 4
  004d6	0f b6 04 45 00
	00 00 00	 movzx	 eax, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  004de	88 42 f8	 mov	 BYTE PTR [edx-8], al
  004e1	81 f9 11 00 00
	00		 cmp	 ecx, OFFSET ?gBits@@3PAY03EA+17
  004e7	7c b7		 jl	 SHORT $LL31@Decompress
  004e9	8b 5d 84	 mov	 ebx, DWORD PTR _alphazero$1$[ebp]

; 644  : 
; 645  : 			assert(gACol[row][pix].r == 0);
; 646  : 			assert(gACol[row][pix].g == 0);
; 647  : 			assert(gACol[row][pix].b == 0);
; 648  : 		}
; 649  : 	}
; 650  : 
; 651  : 	// Write out alpha values to the image bits
; 652  : 	for (row = 0; row < 4; ++row, pImPos += width - 4)

  004ec	ba 04 00 00 00	 mov	 edx, OFFSET ?gACol@@3PAY03UColor8888@@A+4
$LL37@Decompress:

; 653  : 	{
; 654  : 		// pImPow += pImPos += width - 4 moves to next row down
; 655  : 		for (pix = 0; pix < 4; ++pix)
; 656  : 		{
; 657  : 			// zero the alpha bits of image pixel
; 658  : 			*pImPos &= alphazero;

  004f1	21 1e		 and	 DWORD PTR [esi], ebx

; 659  : 			*pImPos |= *((DWORD*) & (gACol[row][pix]));	// or the bits into the prev. nulled alpha

  004f3	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  004f6	09 06		 or	 DWORD PTR [esi], eax
  004f8	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  004fb	23 cb		 and	 ecx, ebx
  004fd	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00500	8b 02		 mov	 eax, DWORD PTR [edx]
  00502	0b c1		 or	 eax, ecx
  00504	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00507	23 cb		 and	 ecx, ebx
  00509	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0050c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0050f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00512	0b c1		 or	 eax, ecx
  00514	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00517	23 cb		 and	 ecx, ebx
  00519	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0051c	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  0051f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00522	83 c2 10	 add	 edx, 16			; 00000010H
  00525	0b c1		 or	 eax, ecx
  00527	8b 4d a4	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  0052a	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0052d	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00534	03 f0		 add	 esi, eax
  00536	81 fa 44 00 00
	00		 cmp	 edx, OFFSET ?gACol@@3PAY03UColor8888@@A+68
  0053c	7c b3		 jl	 SHORT $LL37@Decompress

; 845  : 
; 846  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  0053e	8b 75 a0	 mov	 esi, DWORD PTR _pBlock$1$[ebp]
  00541	83 45 b8 40	 add	 DWORD PTR tv2483[ebp], 64 ; 00000040H
  00545	83 c6 08	 add	 esi, 8
  00548	83 6d 9c 01	 sub	 DWORD PTR tv2532[ebp], 1
  0054c	0f 85 71 fb ff
	ff		 jne	 $LL7@Decompress
  00552	8b 5d 8c	 mov	 ebx, DWORD PTR _yblocks$1$[ebp]
  00555	8b 4d 94	 mov	 ecx, DWORD PTR _pPos$1$[ebp]
  00558	8b 7d 90	 mov	 edi, DWORD PTR _pdwDest$GSCopy$1$[ebp]
  0055b	8b 55 98	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
  0055e	8b 45 80	 mov	 eax, DWORD PTR tv2481[ebp]
$LN2@Decompress:

; 837  : 
; 838  : 	////////////////////////////////
; 839  : 	// Tracef("blocks: x: %d y: %d\n", xblocks, yblocks);
; 840  : 	for (y = 0; y < yblocks; ++y)

  00561	03 8d 7c ff ff
	ff		 add	 ecx, DWORD PTR tv2480[ebp]
  00567	03 f8		 add	 edi, eax
  00569	83 eb 01	 sub	 ebx, 1
  0056c	89 4d 94	 mov	 DWORD PTR _pPos$1$[ebp], ecx
  0056f	89 7d 90	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], edi
  00572	89 5d 8c	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
  00575	0f 85 05 fb ff
	ff		 jne	 $LL4@Decompress
$LN3@Decompress:

; 869  : 		}
; 870  : 	}
; 871  : }	// dxt5

  0057b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0057e	5f		 pop	 edi
  0057f	5e		 pop	 esi
  00580	33 cd		 xor	 ecx, ebp
  00582	5b		 pop	 ebx
  00583	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00588	8b e5		 mov	 esp, ebp
  0058a	5d		 pop	 ebp
  0058b	c2 08 00	 ret	 8
  0058e	66 90		 npad	 2
$LN91@Decompress:
  00590	00 00 00 00	 DD	 $LN22@Decompress
  00594	00 00 00 00	 DD	 $LN23@Decompress
  00598	00 00 00 00	 DD	 $LN24@Decompress
  0059c	00 00 00 00	 DD	 $LN25@Decompress
?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT5
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
tv1621 = -136						; size = 4
tv1622 = -132						; size = 4
_pAlphaBlock$1$ = -128					; size = 4
_alphazero$1$ = -124					; size = 4
tv1611 = -120						; size = 4
_yblocks$1$ = -116					; size = 4
_pdwDest$GSCopy$1$ = -112				; size = 4
_pPos$1$ = -108						; size = 4
_xblocks$1$ = -104					; size = 4
tv1647 = -100						; size = 4
_pBlock$1$ = -96					; size = 4
_nWidth$1$ = -92					; size = 4
tv1617 = -88						; size = 4
tv1613 = -84						; size = 4
tv1615 = -80						; size = 4
tv1548 = -76						; size = 4
tv1624 = -72						; size = 4
_col_1$ = -68						; size = 4
_pImPos$1$ = -64					; size = 4
tv1551 = -64						; size = 4
_col_2$ = -60						; size = 4
_col_3$ = -56						; size = 4
_col_0$ = -52						; size = 4
_col$1 = -48						; size = 4
tv1612 = -42						; size = 1
tv1645 = -41						; size = 1
_y$1$ = -40						; size = 4
tv1553 = -40						; size = 4
_wrd$2 = -40						; size = 2
_shift$3 = -36						; size = 16
_masks$4 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT3, COMDAT
; _this$ = ecx

; 725  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b d1		 mov	 edx, ecx

; 726  : 	int xblocks, yblocks;
; 727  : #ifdef DEBUG
; 728  : 	if ((ddsd.dwWidth % 4) != 0)
; 729  : 	{
; 730  : 		Tracef("****** warning width not div by 4! %d\n", ddsd.dwWidth);
; 731  : 	}
; 732  : 
; 733  : 	if ((ddsd.dwHeight % 4) != 0)
; 734  : 	{
; 735  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 736  : 	}
; 737  : 
; 738  : 	Tracef("end check\n");
; 739  : #endif
; 740  : 	UINT nWidth = m_nWidth >> miplevel;
; 741  : 	UINT nHeight = m_nHeight >> miplevel;
; 742  : 
; 743  : 	xblocks = nWidth / 4;
; 744  : 	yblocks = nHeight / 4;
; 745  : 
; 746  : 	int		x, y;
; 747  : 	DWORD * pBase	= (DWORD *) pdwDest;
; 748  : 	WORD  * pPos	= (WORD *) &m_bCompVector[miplevel][0]; // pos in compressed data
; 749  : 	DWORD * pImPos;	// pos in decompressed data
; 750  : 
; 751  : 	DXTColBlock	* pBlock;
; 752  : 	DXTAlphaBlockExplicit * pAlphaBlock;
; 753  : 
; 754  : 	Color8888 col_0, col_1, col_2, col_3;
; 755  : 	WORD wrd;
; 756  : 
; 757  : 	// fill alphazero with appropriate value to zero out alpha when
; 758  : 	//  alphazero is ANDed with the image color 32 bit DWORD:
; 759  : 	col_0.a = 0;
; 760  : 	col_0.r = col_0.g = col_0.b = 0xff;

  00015	c7 45 cc ff ff
	ff 00		 mov	 DWORD PTR _col_0$[ebp], 16777215 ; 00ffffffH
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	8b b2 00 01 00
	00		 mov	 esi, DWORD PTR [edx+256]
  00027	8b 9a 04 01 00
	00		 mov	 ebx, DWORD PTR [edx+260]
  0002d	d3 fe		 sar	 esi, cl
  0002f	8b c6		 mov	 eax, esi
  00031	d3 fb		 sar	 ebx, cl
  00033	c1 e8 02	 shr	 eax, 2
  00036	89 45 98	 mov	 DWORD PTR _xblocks$1$[ebp], eax
  00039	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1952 :         return _My_data._Myfirst[_Pos];

  0003c	8b 4c 82 34	 mov	 ecx, DWORD PTR [edx+eax*4+52]
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 762  : 	DWORD alphazero = *((DWORD *) &col_0);

  00040	8b 45 cc	 mov	 eax, DWORD PTR _col_0$[ebp]
  00043	c1 eb 02	 shr	 ebx, 2
  00046	89 75 a4	 mov	 DWORD PTR _nWidth$1$[ebp], esi
  00049	89 5d 8c	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1952 :         return _My_data._Myfirst[_Pos];

  0004c	89 4d 94	 mov	 DWORD PTR _pPos$1$[ebp], ecx
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 762  : 	DWORD alphazero = *((DWORD *) &col_0);

  0004f	89 45 84	 mov	 DWORD PTR _alphazero$1$[ebp], eax
  00052	57		 push	 edi
  00053	8b 7d 0c	 mov	 edi, DWORD PTR _pdwDest$[ebp]
  00056	89 7d 90	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], edi

; 763  : 
; 764  : 	for (y = 0; y < yblocks; ++y)

  00059	85 db		 test	 ebx, ebx
  0005b	0f 84 1d 03 00
	00		 je	 $LN3@Decompress

; 725  : {

  00061	8b 55 98	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
  00064	8b c6		 mov	 eax, esi
  00066	c1 e0 06	 shl	 eax, 6
  00069	8b f2		 mov	 esi, edx
  0006b	c1 e6 05	 shl	 esi, 5
  0006e	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv1622[ebp], eax
  00074	89 b5 78 ff ff
	ff		 mov	 DWORD PTR tv1621[ebp], esi
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Decompress:

; 765  : 	{
; 766  : 		// 8 bytes per block
; 767  : 		// 1 block for alpha, 1 block for color
; 768  : 		pBlock = (DXTColBlock *) ((DWORD) (pPos + y * xblocks * 16));

  00080	8b f1		 mov	 esi, ecx

; 769  : 
; 770  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00082	85 d2		 test	 edx, edx
  00084	0f 84 da 02 00
	00		 je	 $LN2@Decompress

; 463  : 	const int   shift[] = { 0, 2, 4, 6 };

  0008a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000

; 377  : 	col_0->a = 0xff;

  00091	c6 45 cf ff	 mov	 BYTE PTR _col_0$[ebp+3], 255 ; 000000ffH

; 384  : 
; 385  : 	pCol = (Color565*) & (pBlock->col1);
; 386  : 	col_1->a = 0xff;

  00095	c6 45 bf ff	 mov	 BYTE PTR _col_1$[ebp+3], 255 ; 000000ffH

; 434  : 		col_2->r = (BYTE)wrd;
; 435  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);
; 436  : 		col_2->g = (BYTE)wrd;
; 437  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);
; 438  : 		col_2->b = (BYTE)wrd;
; 439  : 		col_2->a = 0xff;

  00099	c6 45 c7 ff	 mov	 BYTE PTR _col_2$[ebp+3], 255 ; 000000ffH

; 462  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  0009d	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _masks$4[ebp], 3
  000a4	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR _masks$4[ebp+4], 12 ; 0000000cH
  000ab	c7 45 f4 30 00
	00 00		 mov	 DWORD PTR _masks$4[ebp+8], 48 ; 00000030H
  000b2	c7 45 f8 c0 00
	00 00		 mov	 DWORD PTR _masks$4[ebp+12], 192 ; 000000c0H

; 463  : 	const int   shift[] = { 0, 2, 4, 6 };

  000b9	0f 11 45 dc	 movups	 XMMWORD PTR _shift$3[ebp], xmm0

; 525  : 	col.r = col.g = col.b = 0;

  000bd	66 c7 45 d0 00
	00		 mov	 WORD PTR _col$1[ebp], 0
  000c3	c6 45 d2 00	 mov	 BYTE PTR _col$1[ebp+2], 0

; 765  : 	{
; 766  : 		// 8 bytes per block
; 767  : 		// 1 block for alpha, 1 block for color
; 768  : 		pBlock = (DXTColBlock *) ((DWORD) (pPos + y * xblocks * 16));

  000c7	89 7d b8	 mov	 DWORD PTR tv1624[ebp], edi
  000ca	89 55 9c	 mov	 DWORD PTR tv1647[ebp], edx
  000cd	0f 1f 00	 npad	 3
$LL7@Decompress:

; 378  : 	col_0->r = pCol->nRed;

  000d0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d3	8b d9		 mov	 ebx, ecx

; 771  : 		{
; 772  : 			// inline
; 773  : 			// Get alpha block
; 774  : 			pAlphaBlock = (DXTAlphaBlockExplicit *) pBlock;

  000d5	89 75 80	 mov	 DWORD PTR _pAlphaBlock$1$[ebp], esi

; 380  : 	col_0->g = pCol->nGreen;

  000d8	8b d1		 mov	 edx, ecx
  000da	c1 ea 05	 shr	 edx, 5

; 775  : 
; 776  : 			// inline func:
; 777  : 			// Get color block & colors
; 778  : 			pBlock++;

  000dd	83 c6 08	 add	 esi, 8

; 381  : 	col_0->g <<= 2;

  000e0	c0 e2 02	 shl	 dl, 2

; 382  : 	col_0->b = pCol->nBlue;
; 383  : 	col_0->b <<= 3;

  000e3	8a c1		 mov	 al, cl
  000e5	89 55 b4	 mov	 DWORD PTR tv1548[ebp], edx
  000e8	88 55 cd	 mov	 BYTE PTR _col_0$[ebp+1], dl
  000eb	c0 e0 03	 shl	 al, 3
  000ee	88 45 d6	 mov	 BYTE PTR tv1612[ebp], al
  000f1	88 45 cc	 mov	 BYTE PTR _col_0$[ebp], al

; 387  : 	col_1->r = pCol->nRed;

  000f4	8b 46 02	 mov	 eax, DWORD PTR [esi+2]
  000f7	8b d0		 mov	 edx, eax
  000f9	c1 ea 0b	 shr	 edx, 11			; 0000000bH

; 388  : 	col_1->r <<= 3;				// shift to full precision

  000fc	c0 e2 03	 shl	 dl, 3
  000ff	89 55 c0	 mov	 DWORD PTR tv1551[ebp], edx
  00102	88 55 be	 mov	 BYTE PTR _col_1$[ebp+2], dl

; 389  : 	col_1->g = pCol->nGreen;

  00105	8b d0		 mov	 edx, eax
  00107	c1 ea 05	 shr	 edx, 5

; 390  : 	col_1->g <<= 2;

  0010a	c0 e2 02	 shl	 dl, 2
  0010d	89 55 d8	 mov	 DWORD PTR tv1553[ebp], edx
  00110	88 55 bd	 mov	 BYTE PTR _col_1$[ebp+1], dl

; 391  : 	col_1->b = pCol->nBlue;
; 392  : 	col_1->b <<= 3;

  00113	8a d0		 mov	 dl, al
  00115	c0 e2 03	 shl	 dl, 3
  00118	88 55 d7	 mov	 BYTE PTR tv1645[ebp], dl
  0011b	88 55 bc	 mov	 BYTE PTR _col_1$[ebp], dl
  0011e	8b 55 c0	 mov	 edx, DWORD PTR tv1551[ebp]

; 775  : 
; 776  : 			// inline func:
; 777  : 			// Get color block & colors
; 778  : 			pBlock++;

  00121	89 75 a0	 mov	 DWORD PTR _pBlock$1$[ebp], esi

; 392  : 	col_1->b <<= 3;

  00124	0f b6 f2	 movzx	 esi, dl
  00127	8b 55 d8	 mov	 edx, DWORD PTR tv1553[ebp]
  0012a	0f b6 fa	 movzx	 edi, dl
  0012d	0f b6 55 d7	 movzx	 edx, BYTE PTR tv1645[ebp]
  00131	c1 eb 0b	 shr	 ebx, 11			; 0000000bH
  00134	c0 e3 03	 shl	 bl, 3

; 393  : 
; 394  : 	if (pBlock->col0 > pBlock->col1)

  00137	66 3b c8	 cmp	 cx, ax
  0013a	89 55 a8	 mov	 DWORD PTR tv1617[ebp], edx
  0013d	0f b6 d3	 movzx	 edx, bl
  00140	89 55 b0	 mov	 DWORD PTR tv1615[ebp], edx
  00143	8b 55 b4	 mov	 edx, DWORD PTR tv1548[ebp]
  00146	8b 45 b0	 mov	 eax, DWORD PTR tv1615[ebp]
  00149	0f b6 d2	 movzx	 edx, dl
  0014c	89 55 ac	 mov	 DWORD PTR tv1613[ebp], edx
  0014f	0f b6 55 d6	 movzx	 edx, BYTE PTR tv1612[ebp]
  00153	88 5d ce	 mov	 BYTE PTR _col_0$[ebp+2], bl
  00156	89 55 88	 mov	 DWORD PTR tv1611[ebp], edx
  00159	0f 86 86 00 00
	00		 jbe	 $LN10@Decompress

; 395  : 	{
; 396  : 		// Four-color block: derive the other two colors.
; 397  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 398  : 		// These two bit codes correspond to the 2-bit fields
; 399  : 		// stored in the 64-bit block.
; 400  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);

  0015f	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]

; 401  : 		// no +1 for rounding
; 402  : 		// as bits have been shifted to 888
; 403  : 		col_2->r = (BYTE)wrd;
; 404  : 
; 405  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);
; 406  : 		col_2->g = (BYTE)wrd;
; 407  : 
; 408  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);
; 409  : 		col_2->b = (BYTE)wrd;
; 410  : 		col_2->a = 0xff;
; 411  : 
; 412  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);
; 413  : 		col_3->r = (BYTE)wrd;
; 414  : 
; 415  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);
; 416  : 		col_3->g = (BYTE)wrd;
; 417  : 
; 418  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);
; 419  : 		col_3->b = (BYTE)wrd;
; 420  : 		col_3->a = 0xff;

  00162	c6 45 cb ff	 mov	 BYTE PTR _col_3$[ebp+3], 255 ; 000000ffH
  00166	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0016b	f7 e1		 mul	 ecx
  0016d	8b 45 ac	 mov	 eax, DWORD PTR tv1613[ebp]
  00170	d1 ea		 shr	 edx, 1
  00172	88 55 c6	 mov	 BYTE PTR _col_2$[ebp+2], dl
  00175	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  00178	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0017d	f7 e1		 mul	 ecx
  0017f	8b 45 a8	 mov	 eax, DWORD PTR tv1617[ebp]
  00182	8b 4d 88	 mov	 ecx, DWORD PTR tv1611[ebp]
  00185	d1 ea		 shr	 edx, 1
  00187	88 55 c5	 mov	 BYTE PTR _col_2$[ebp+1], dl
  0018a	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0018d	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00192	f7 e1		 mul	 ecx
  00194	8b 45 c0	 mov	 eax, DWORD PTR tv1551[ebp]
  00197	0f b6 c8	 movzx	 ecx, al
  0019a	d1 ea		 shr	 edx, 1
  0019c	0f b6 c3	 movzx	 eax, bl
  0019f	88 55 c4	 mov	 BYTE PTR _col_2$[ebp], dl
  001a2	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001a5	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001aa	f7 e1		 mul	 ecx
  001ac	8b 45 d8	 mov	 eax, DWORD PTR tv1553[ebp]
  001af	0f b6 c8	 movzx	 ecx, al
  001b2	8b 45 b4	 mov	 eax, DWORD PTR tv1548[ebp]
  001b5	0f b6 c0	 movzx	 eax, al
  001b8	d1 ea		 shr	 edx, 1
  001ba	88 55 ca	 mov	 BYTE PTR _col_3$[ebp+2], dl
  001bd	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001c0	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001c5	f7 e1		 mul	 ecx
  001c7	0f b6 45 d6	 movzx	 eax, BYTE PTR tv1612[ebp]
  001cb	0f b6 4d d7	 movzx	 ecx, BYTE PTR tv1645[ebp]
  001cf	d1 ea		 shr	 edx, 1
  001d1	88 55 c9	 mov	 BYTE PTR _col_3$[ebp+1], dl
  001d4	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001d7	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001dc	f7 e1		 mul	 ecx
  001de	d1 ea		 shr	 edx, 1
  001e0	88 55 c8	 mov	 BYTE PTR _col_3$[ebp], dl

; 421  : 	}

  001e3	eb 29		 jmp	 SHORT $LN11@Decompress
$LN10@Decompress:

; 422  : 	else
; 423  : 	{
; 424  : 		// Three-color block: derive the other color.
; 425  : 		// 00 = color_0,  01 = color_1,  10 = color_2,
; 426  : 		// 11 = transparent.
; 427  : 		// These two bit codes correspond to the 2-bit fields
; 428  : 		// stored in the 64-bit block.
; 429  : 
; 430  : 		// explicit for each component, unlike some refrasts...
; 431  : 
; 432  : 		// Tracef("block has alpha\n");
; 433  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  001e5	03 c6		 add	 eax, esi

; 440  : 
; 441  : 		col_3->r = 0x00;		// random color to indicate alpha
; 442  : 		col_3->g = 0x00;

  001e7	66 c7 45 c9 00
	00		 mov	 WORD PTR _col_3$[ebp+1], 0
  001ed	d1 e8		 shr	 eax, 1
  001ef	88 45 c6	 mov	 BYTE PTR _col_2$[ebp+2], al
  001f2	8b 45 ac	 mov	 eax, DWORD PTR tv1613[ebp]
  001f5	03 c7		 add	 eax, edi

; 443  : 		col_3->b = 0x00;

  001f7	c6 45 c8 00	 mov	 BYTE PTR _col_3$[ebp], 0
  001fb	d1 e8		 shr	 eax, 1
  001fd	88 45 c5	 mov	 BYTE PTR _col_2$[ebp+1], al
  00200	8b 45 a8	 mov	 eax, DWORD PTR tv1617[ebp]
  00203	03 c2		 add	 eax, edx

; 444  : 		col_3->a = 0x00;

  00205	c6 45 cb 00	 mov	 BYTE PTR _col_3$[ebp+3], 0
  00209	d1 e8		 shr	 eax, 1
  0020b	88 45 c4	 mov	 BYTE PTR _col_2$[ebp], al
$LN11@Decompress:

; 779  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 780  : 
; 781  : 			// Decode the color block into the bitmap bits
; 782  : 			// inline func:
; 783  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 784  : 
; 785  : 			DecodeColorBlock(pImPos,

  0020e	8b 55 b8	 mov	 edx, DWORD PTR tv1624[ebp]

; 466  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  00211	33 c0		 xor	 eax, eax
  00213	8b 75 cc	 mov	 esi, DWORD PTR _col_0$[ebp]
  00216	8b 7d c8	 mov	 edi, DWORD PTR _col_3$[ebp]

; 779  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 780  : 
; 781  : 			// Decode the color block into the bitmap bits
; 782  : 			// inline func:
; 783  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 784  : 
; 785  : 			DecodeColorBlock(pImPos,

  00219	89 55 c0	 mov	 DWORD PTR _pImPos$1$[ebp], edx

; 466  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  0021c	89 45 d8	 mov	 DWORD PTR _y$1$[ebp], eax
  0021f	90		 npad	 1
$LL16@Decompress:

; 467  : 	{
; 468  : 		// width * 4 bytes per pixel per line
; 469  : 		// each j dxtc row is 4 lines of pixels
; 470  : 
; 471  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 472  : 
; 473  : 		// n steps through pixels
; 474  : 		for (n = 0; n < 4; ++n)

  00220	33 db		 xor	 ebx, ebx
$LL19@Decompress:

; 475  : 		{
; 476  : 			bits = pColorBlock->row[y] & masks[n];

  00222	8b 4d a0	 mov	 ecx, DWORD PTR _pBlock$1$[ebp]
  00225	0f b6 4c 08 04	 movzx	 ecx, BYTE PTR [eax+ecx+4]
  0022a	8b 44 1d ec	 mov	 eax, DWORD PTR _masks$4[ebp+ebx]
  0022e	23 c1		 and	 eax, ecx

; 477  : 			bits >>= shift[n];

  00230	8b 4c 1d dc	 mov	 ecx, DWORD PTR _shift$3[ebp+ebx]
  00234	d3 e8		 shr	 eax, cl

; 478  : 
; 479  : 			switch (bits)

  00236	83 f8 03	 cmp	 eax, 3
  00239	77 1d		 ja	 SHORT $LN26@Decompress
  0023b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN70@Decompress[eax*4]
$LN22@Decompress:

; 480  : 			{
; 481  : 			case 0:
; 482  : 				*pImPos = *col_0;

  00242	89 32		 mov	 DWORD PTR [edx], esi

; 483  : 				pImPos++; // increment to next DWORD
; 484  : 				break;

  00244	eb 23		 jmp	 SHORT $LN17@Decompress
$LN23@Decompress:

; 485  : 
; 486  : 			case 1:
; 487  : 				*pImPos = *col_1;

  00246	8b 45 bc	 mov	 eax, DWORD PTR _col_1$[ebp]
  00249	89 02		 mov	 DWORD PTR [edx], eax

; 488  : 				pImPos++;
; 489  : 				break;

  0024b	eb 1c		 jmp	 SHORT $LN17@Decompress
$LN24@Decompress:

; 490  : 
; 491  : 			case 2:
; 492  : 				*pImPos = *col_2;

  0024d	8b 45 c4	 mov	 eax, DWORD PTR _col_2$[ebp]
  00250	89 02		 mov	 DWORD PTR [edx], eax

; 493  : 				pImPos++;
; 494  : 				break;

  00252	eb 15		 jmp	 SHORT $LN17@Decompress
$LN25@Decompress:

; 495  : 
; 496  : 			case 3:
; 497  : 				*pImPos = *col_3;

  00254	89 3a		 mov	 DWORD PTR [edx], edi

; 498  : 				pImPos++;
; 499  : 				break;

  00256	eb 11		 jmp	 SHORT $LN17@Decompress
$LN26@Decompress:

; 500  : 
; 501  : 			default:
; 502  : 				Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  00258	50		 push	 eax
  00259	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  0025e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00263	8b 55 c0	 mov	 edx, DWORD PTR _pImPos$1$[ebp]
  00266	83 c4 08	 add	 esp, 8
$LN17@Decompress:

; 467  : 	{
; 468  : 		// width * 4 bytes per pixel per line
; 469  : 		// each j dxtc row is 4 lines of pixels
; 470  : 
; 471  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 472  : 
; 473  : 		// n steps through pixels
; 474  : 		for (n = 0; n < 4; ++n)

  00269	8b 45 d8	 mov	 eax, DWORD PTR _y$1$[ebp]
  0026c	83 c2 04	 add	 edx, 4
  0026f	83 c3 04	 add	 ebx, 4
  00272	89 55 c0	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  00275	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00278	7c a8		 jl	 SHORT $LL19@Decompress

; 464  : 
; 465  : 	// r steps through lines in y
; 466  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  0027a	8b 5d a4	 mov	 ebx, DWORD PTR _nWidth$1$[ebp]
  0027d	40		 inc	 eax
  0027e	89 45 d8	 mov	 DWORD PTR _y$1$[ebp], eax
  00281	8d 0c 9d f0 ff
	ff ff		 lea	 ecx, DWORD PTR [ebx*4-16]
  00288	03 d1		 add	 edx, ecx
  0028a	89 55 c0	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  0028d	83 f8 04	 cmp	 eax, 4
  00290	7c 8e		 jl	 SHORT $LL16@Decompress

; 786  : 							 pBlock,
; 787  : 							 nWidth,
; 788  : 							 (DWORD *) &col_0, (DWORD *) &col_1, (DWORD *) &col_2, (DWORD *) &col_3);
; 789  : 
; 790  : 			// Overwrite the previous alpha bits with the alpha block
; 791  : 			//  info
; 792  : 			// inline func:
; 793  : 			DecodeAlphaExplicit(pImPos, pAlphaBlock, nWidth, alphazero);

  00292	8b 75 b8	 mov	 esi, DWORD PTR tv1624[ebp]
  00295	33 ff		 xor	 edi, edi
  00297	8b 5d 84	 mov	 ebx, DWORD PTR _alphazero$1$[ebp]
  0029a	66 0f 1f 44 00
	00		 npad	 6
$LL31@Decompress:

; 531  : 		wrd = pAlphaBlock->row[row];

  002a0	8b 45 80	 mov	 eax, DWORD PTR _pAlphaBlock$1$[ebp]
  002a3	0f b7 04 78	 movzx	 eax, WORD PTR [eax+edi*2]
  002a7	47		 inc	 edi

; 532  : 
; 533  : 		// Tracef("0x%.8x\t\t", wrd);
; 534  : 		for (pix = 0; pix < 4; ++pix)
; 535  : 		{
; 536  : 			// zero the alpha bits of image pixel
; 537  : 			*pImPos &= alphazero;
; 538  : 
; 539  : 			col.a = (BYTE) (wrd & 0x000f);		// get only low 4 bits

  002a8	8a c8		 mov	 cl, al
  002aa	89 45 d8	 mov	 DWORD PTR _wrd$2[ebp], eax

; 540  : 			//			col.a <<= 4;				// shift to full byte precision
; 541  : 			// NOTE:  with just a << 4 you'll never have alpha
; 542  : 			// of 0xff,  0xf0 is max so pure shift doesn't quite
; 543  : 			// cover full alpha range.
; 544  : 			// It's much cheaper than divide & scale though.
; 545  : 			// To correct for this, and get 0xff for max alpha,
; 546  : 			//  or the low bits back in after left shifting
; 547  : 			col.a = (BYTE) (col.a | (col.a << 4));	// This allows max 4 bit alpha to be 0xff alpha
; 548  : 			//  in final image, and is crude approach to full
; 549  : 			//  range scale
; 550  : 
; 551  : 			*pImPos |= *((DWORD*)&col);	// or the bits into the prev. nulled alpha
; 552  : 
; 553  : 			wrd >>= 4; // move next bits to lowest 4

  002ad	66 8b 55 d8	 mov	 dx, WORD PTR _wrd$2[ebp]
  002b1	80 e1 0f	 and	 cl, 15			; 0000000fH
  002b4	8a c1		 mov	 al, cl
  002b6	66 c1 ea 04	 shr	 dx, 4
  002ba	c0 e0 04	 shl	 al, 4
  002bd	0a c1		 or	 al, cl
  002bf	66 89 55 d8	 mov	 WORD PTR _wrd$2[ebp], dx
  002c3	88 45 d3	 mov	 BYTE PTR _col$1[ebp+3], al
  002c6	8a ca		 mov	 cl, dl
  002c8	80 e1 0f	 and	 cl, 15			; 0000000fH
  002cb	66 c1 ea 04	 shr	 dx, 4
  002cf	8b c3		 mov	 eax, ebx
  002d1	66 89 55 d8	 mov	 WORD PTR _wrd$2[ebp], dx
  002d5	23 06		 and	 eax, DWORD PTR [esi]
  002d7	0b 45 d0	 or	 eax, DWORD PTR _col$1[ebp]
  002da	89 06		 mov	 DWORD PTR [esi], eax
  002dc	8a c1		 mov	 al, cl
  002de	c0 e0 04	 shl	 al, 4
  002e1	0a c1		 or	 al, cl
  002e3	8a ca		 mov	 cl, dl
  002e5	88 45 d3	 mov	 BYTE PTR _col$1[ebp+3], al
  002e8	80 e1 0f	 and	 cl, 15			; 0000000fH
  002eb	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002ee	23 c3		 and	 eax, ebx
  002f0	0b 45 d0	 or	 eax, DWORD PTR _col$1[ebp]
  002f3	89 46 04	 mov	 DWORD PTR [esi+4], eax
  002f6	8a c1		 mov	 al, cl
  002f8	c0 e0 04	 shl	 al, 4
  002fb	0a c1		 or	 al, cl
  002fd	8b 4d d8	 mov	 ecx, DWORD PTR _wrd$2[ebp]
  00300	88 45 d3	 mov	 BYTE PTR _col$1[ebp+3], al
  00303	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00306	23 c3		 and	 eax, ebx
  00308	c1 e9 04	 shr	 ecx, 4
  0030b	0b 45 d0	 or	 eax, DWORD PTR _col$1[ebp]
  0030e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00311	8a c1		 mov	 al, cl
  00313	c0 e0 04	 shl	 al, 4
  00316	0a c1		 or	 al, cl
  00318	8b 4d a4	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  0031b	88 45 d3	 mov	 BYTE PTR _col$1[ebp+3], al
  0031e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00321	23 c3		 and	 eax, ebx
  00323	0b 45 d0	 or	 eax, DWORD PTR _col$1[ebp]
  00326	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00329	83 c6 10	 add	 esi, 16			; 00000010H
  0032c	8d 04 8d f0 ff
	ff ff		 lea	 eax, DWORD PTR [ecx*4-16]
  00333	03 f0		 add	 esi, eax
  00335	83 ff 04	 cmp	 edi, 4
  00338	0f 8c 62 ff ff
	ff		 jl	 $LL31@Decompress

; 769  : 
; 770  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  0033e	8b 75 a0	 mov	 esi, DWORD PTR _pBlock$1$[ebp]
  00341	83 45 b8 40	 add	 DWORD PTR tv1624[ebp], 64 ; 00000040H
  00345	83 c6 08	 add	 esi, 8
  00348	83 6d 9c 01	 sub	 DWORD PTR tv1647[ebp], 1
  0034c	0f 85 7e fd ff
	ff		 jne	 $LL7@Decompress
  00352	8b 5d 8c	 mov	 ebx, DWORD PTR _yblocks$1$[ebp]
  00355	8b 4d 94	 mov	 ecx, DWORD PTR _pPos$1$[ebp]
  00358	8b 7d 90	 mov	 edi, DWORD PTR _pdwDest$GSCopy$1$[ebp]
  0035b	8b 55 98	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
  0035e	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv1622[ebp]
$LN2@Decompress:

; 763  : 
; 764  : 	for (y = 0; y < yblocks; ++y)

  00364	03 8d 78 ff ff
	ff		 add	 ecx, DWORD PTR tv1621[ebp]
  0036a	03 f8		 add	 edi, eax
  0036c	83 eb 01	 sub	 ebx, 1
  0036f	89 4d 94	 mov	 DWORD PTR _pPos$1$[ebp], ecx
  00372	89 7d 90	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], edi
  00375	89 5d 8c	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
  00378	0f 85 02 fd ff
	ff		 jne	 $LL4@Decompress
$LN3@Decompress:

; 794  : 		}
; 795  : 	}
; 796  : }

  0037e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00381	5f		 pop	 edi
  00382	5e		 pop	 esi
  00383	33 cd		 xor	 ecx, ebp
  00385	5b		 pop	 ebx
  00386	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038b	8b e5		 mov	 esp, ebp
  0038d	5d		 pop	 ebp
  0038e	c2 08 00	 ret	 8
  00391	0f 1f 00	 npad	 3
$LN70@Decompress:
  00394	00 00 00 00	 DD	 $LN22@Decompress
  00398	00 00 00 00	 DD	 $LN23@Decompress
  0039c	00 00 00 00	 DD	 $LN24@Decompress
  003a0	00 00 00 00	 DD	 $LN25@Decompress
?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_nWidth$1$ = -120					; size = 4
tv1120 = -116						; size = 4
_yblocks$1$ = -112					; size = 4
_pdwDest$GSCopy$1$ = -108				; size = 4
_pPos$1$ = -104						; size = 4
tv1119 = -100						; size = 4
_xblocks$1$ = -96					; size = 4
tv1146 = -92						; size = 4
tv1132 = -88						; size = 4
tv1122 = -84						; size = 4
tv1124 = -80						; size = 4
tv1063 = -76						; size = 4
_pBlock$1$ = -72					; size = 4
tv1133 = -68						; size = 4
_col_1$ = -64						; size = 4
_col_0$ = -60						; size = 4
_pImPos$1$ = -56					; size = 4
tv1066 = -56						; size = 4
_y$1$ = -52						; size = 4
tv1068 = -52						; size = 4
_col_2$ = -48						; size = 4
_col_3$ = -44						; size = 4
tv1121 = -38						; size = 1
tv1131 = -37						; size = 1
_shift$1 = -36						; size = 16
_masks$2 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT1, COMDAT
; _this$ = ecx

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b d1		 mov	 edx, ecx
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi

; 667  : 	// This was hacked up pretty quick & slopily
; 668  : 	// decompresses to 32 bit format 0xARGB
; 669  : 	int xblocks, yblocks;
; 670  : #ifdef DEBUG
; 671  : 	if ((ddsd.dwWidth % 4) != 0)
; 672  : 	{
; 673  : 		Tracef("****** warning width not div by 4!  %d\n", ddsd.dwWidth);
; 674  : 	}
; 675  : 
; 676  : 	if ((ddsd.dwHeight % 4) != 0)
; 677  : 	{
; 678  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 679  : 	}
; 680  : 
; 681  : 	Tracef("end check\n");
; 682  : #endif
; 683  : 	UINT nWidth = m_nWidth >> miplevel;

  00018	8b b2 00 01 00
	00		 mov	 esi, DWORD PTR [edx+256]

; 684  : 	UINT nHeight = m_nHeight >> miplevel;

  0001e	8b 9a 04 01 00
	00		 mov	 ebx, DWORD PTR [edx+260]
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _pdwDest$[ebp]
  00027	d3 fe		 sar	 esi, cl

; 685  : 
; 686  : 	xblocks = nWidth / 4;

  00029	8b c6		 mov	 eax, esi
  0002b	d3 fb		 sar	 ebx, cl
  0002d	c1 e8 02	 shr	 eax, 2
  00030	89 45 a0	 mov	 DWORD PTR _xblocks$1$[ebp], eax

; 688  : 
; 689  : 	int		x, y;
; 690  : 	DWORD * pBase	= (DWORD *) pdwDest;
; 691  : 	WORD  * pPos	= (WORD *) &m_bCompVector[miplevel][0];;	// pos in compressed data

  00033	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1952 :         return _My_data._Myfirst[_Pos];

  00036	8b 44 82 34	 mov	 eax, DWORD PTR [edx+eax*4+52]
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 687  : 	yblocks = nHeight / 4;

  0003a	c1 eb 02	 shr	 ebx, 2
  0003d	89 7d 94	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], edi
  00040	89 75 88	 mov	 DWORD PTR _nWidth$1$[ebp], esi
  00043	89 5d 90	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1952 :         return _My_data._Myfirst[_Pos];

  00046	89 45 98	 mov	 DWORD PTR _pPos$1$[ebp], eax
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 699  : 	for (y = 0; y < yblocks; ++y)

  00049	85 db		 test	 ebx, ebx
  0004b	0f 84 51 02 00
	00		 je	 $LN3@Decompress

; 666  : {

  00051	8b ce		 mov	 ecx, esi
  00053	c1 e1 04	 shl	 ecx, 4
  00056	89 4d 9c	 mov	 DWORD PTR tv1119[ebp], ecx
  00059	8b 4d a0	 mov	 ecx, DWORD PTR _xblocks$1$[ebp]
  0005c	8b 55 9c	 mov	 edx, DWORD PTR tv1119[ebp]
  0005f	90		 npad	 1
$LL4@Decompress:

; 700  : 	{
; 701  : 		// 8 bytes per block
; 702  : 		pBlock = (DXTColBlock *) ((DWORD) pPos + y * xblocks * 8);

  00060	8b f0		 mov	 esi, eax
  00062	89 75 b8	 mov	 DWORD PTR _pBlock$1$[ebp], esi

; 703  : 
; 704  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00065	85 c9		 test	 ecx, ecx
  00067	0f 84 18 02 00
	00		 je	 $LN2@Decompress

; 463  : 	const int   shift[] = { 0, 2, 4, 6 };

  0006d	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000

; 377  : 	col_0->a = 0xff;

  00074	c6 45 c7 ff	 mov	 BYTE PTR _col_0$[ebp+3], 255 ; 000000ffH

; 384  : 
; 385  : 	pCol = (Color565*) & (pBlock->col1);
; 386  : 	col_1->a = 0xff;

  00078	c6 45 c3 ff	 mov	 BYTE PTR _col_1$[ebp+3], 255 ; 000000ffH

; 434  : 		col_2->r = (BYTE)wrd;
; 435  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);
; 436  : 		col_2->g = (BYTE)wrd;
; 437  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);
; 438  : 		col_2->b = (BYTE)wrd;
; 439  : 		col_2->a = 0xff;

  0007c	c6 45 d3 ff	 mov	 BYTE PTR _col_2$[ebp+3], 255 ; 000000ffH

; 462  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  00080	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _masks$2[ebp], 3
  00087	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+4], 12 ; 0000000cH
  0008e	c7 45 f4 30 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+8], 48 ; 00000030H
  00095	c7 45 f8 c0 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+12], 192 ; 000000c0H

; 463  : 	const int   shift[] = { 0, 2, 4, 6 };

  0009c	0f 11 45 dc	 movups	 XMMWORD PTR _shift$1[ebp], xmm0

; 700  : 	{
; 701  : 		// 8 bytes per block
; 702  : 		pBlock = (DXTColBlock *) ((DWORD) pPos + y * xblocks * 8);

  000a0	89 7d bc	 mov	 DWORD PTR tv1133[ebp], edi
  000a3	89 4d a4	 mov	 DWORD PTR tv1146[ebp], ecx
$LL7@Decompress:

; 378  : 	col_0->r = pCol->nRed;

  000a6	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 379  : 	col_0->r <<= 3;				// shift to full precision
; 380  : 	col_0->g = pCol->nGreen;

  000a8	8b d1		 mov	 edx, ecx
  000aa	c1 ea 05	 shr	 edx, 5

; 381  : 	col_0->g <<= 2;
; 382  : 	col_0->b = pCol->nBlue;
; 383  : 	col_0->b <<= 3;

  000ad	8a c1		 mov	 al, cl
  000af	c0 e2 02	 shl	 dl, 2
  000b2	8b d9		 mov	 ebx, ecx
  000b4	89 55 b4	 mov	 DWORD PTR tv1063[ebp], edx
  000b7	88 55 c5	 mov	 BYTE PTR _col_0$[ebp+1], dl
  000ba	c0 e0 03	 shl	 al, 3
  000bd	88 45 da	 mov	 BYTE PTR tv1121[ebp], al
  000c0	88 45 c4	 mov	 BYTE PTR _col_0$[ebp], al

; 387  : 	col_1->r = pCol->nRed;

  000c3	8b 46 02	 mov	 eax, DWORD PTR [esi+2]
  000c6	8b d0		 mov	 edx, eax
  000c8	c1 ea 0b	 shr	 edx, 11			; 0000000bH

; 388  : 	col_1->r <<= 3;				// shift to full precision

  000cb	c0 e2 03	 shl	 dl, 3
  000ce	89 55 c8	 mov	 DWORD PTR tv1066[ebp], edx
  000d1	88 55 c2	 mov	 BYTE PTR _col_1$[ebp+2], dl

; 389  : 	col_1->g = pCol->nGreen;

  000d4	8b d0		 mov	 edx, eax
  000d6	c1 ea 05	 shr	 edx, 5

; 390  : 	col_1->g <<= 2;

  000d9	c0 e2 02	 shl	 dl, 2
  000dc	89 55 cc	 mov	 DWORD PTR tv1068[ebp], edx
  000df	88 55 c1	 mov	 BYTE PTR _col_1$[ebp+1], dl

; 391  : 	col_1->b = pCol->nBlue;
; 392  : 	col_1->b <<= 3;

  000e2	8a d0		 mov	 dl, al
  000e4	c0 e2 03	 shl	 dl, 3
  000e7	88 55 db	 mov	 BYTE PTR tv1131[ebp], dl
  000ea	88 55 c0	 mov	 BYTE PTR _col_1$[ebp], dl
  000ed	8b 55 c8	 mov	 edx, DWORD PTR tv1066[ebp]
  000f0	0f b6 f2	 movzx	 esi, dl
  000f3	8b 55 cc	 mov	 edx, DWORD PTR tv1068[ebp]
  000f6	0f b6 fa	 movzx	 edi, dl
  000f9	0f b6 55 db	 movzx	 edx, BYTE PTR tv1131[ebp]
  000fd	c1 eb 0b	 shr	 ebx, 11			; 0000000bH
  00100	c0 e3 03	 shl	 bl, 3

; 393  : 
; 394  : 	if (pBlock->col0 > pBlock->col1)

  00103	66 3b c8	 cmp	 cx, ax
  00106	89 55 a8	 mov	 DWORD PTR tv1132[ebp], edx
  00109	0f b6 d3	 movzx	 edx, bl
  0010c	89 55 b0	 mov	 DWORD PTR tv1124[ebp], edx
  0010f	8b 55 b4	 mov	 edx, DWORD PTR tv1063[ebp]
  00112	8b 45 b0	 mov	 eax, DWORD PTR tv1124[ebp]
  00115	0f b6 d2	 movzx	 edx, dl
  00118	89 55 ac	 mov	 DWORD PTR tv1122[ebp], edx
  0011b	0f b6 55 da	 movzx	 edx, BYTE PTR tv1121[ebp]
  0011f	88 5d c6	 mov	 BYTE PTR _col_0$[ebp+2], bl
  00122	89 55 8c	 mov	 DWORD PTR tv1120[ebp], edx
  00125	0f 86 86 00 00
	00		 jbe	 $LN10@Decompress

; 395  : 	{
; 396  : 		// Four-color block: derive the other two colors.
; 397  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 398  : 		// These two bit codes correspond to the 2-bit fields
; 399  : 		// stored in the 64-bit block.
; 400  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);

  0012b	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]

; 401  : 		// no +1 for rounding
; 402  : 		// as bits have been shifted to 888
; 403  : 		col_2->r = (BYTE)wrd;
; 404  : 
; 405  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);
; 406  : 		col_2->g = (BYTE)wrd;
; 407  : 
; 408  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);
; 409  : 		col_2->b = (BYTE)wrd;
; 410  : 		col_2->a = 0xff;
; 411  : 
; 412  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);
; 413  : 		col_3->r = (BYTE)wrd;
; 414  : 
; 415  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);
; 416  : 		col_3->g = (BYTE)wrd;
; 417  : 
; 418  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);
; 419  : 		col_3->b = (BYTE)wrd;
; 420  : 		col_3->a = 0xff;

  0012e	c6 45 d7 ff	 mov	 BYTE PTR _col_3$[ebp+3], 255 ; 000000ffH
  00132	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00137	f7 e1		 mul	 ecx
  00139	8b 45 ac	 mov	 eax, DWORD PTR tv1122[ebp]
  0013c	d1 ea		 shr	 edx, 1
  0013e	88 55 d2	 mov	 BYTE PTR _col_2$[ebp+2], dl
  00141	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  00144	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00149	f7 e1		 mul	 ecx
  0014b	8b 45 a8	 mov	 eax, DWORD PTR tv1132[ebp]
  0014e	8b 4d 8c	 mov	 ecx, DWORD PTR tv1120[ebp]
  00151	d1 ea		 shr	 edx, 1
  00153	88 55 d1	 mov	 BYTE PTR _col_2$[ebp+1], dl
  00156	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00159	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0015e	f7 e1		 mul	 ecx
  00160	8b 45 c8	 mov	 eax, DWORD PTR tv1066[ebp]
  00163	0f b6 c8	 movzx	 ecx, al
  00166	d1 ea		 shr	 edx, 1
  00168	0f b6 c3	 movzx	 eax, bl
  0016b	88 55 d0	 mov	 BYTE PTR _col_2$[ebp], dl
  0016e	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00171	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00176	f7 e1		 mul	 ecx
  00178	8b 45 cc	 mov	 eax, DWORD PTR tv1068[ebp]
  0017b	0f b6 c8	 movzx	 ecx, al
  0017e	8b 45 b4	 mov	 eax, DWORD PTR tv1063[ebp]
  00181	0f b6 c0	 movzx	 eax, al
  00184	d1 ea		 shr	 edx, 1
  00186	88 55 d6	 mov	 BYTE PTR _col_3$[ebp+2], dl
  00189	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0018c	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00191	f7 e1		 mul	 ecx
  00193	0f b6 45 da	 movzx	 eax, BYTE PTR tv1121[ebp]
  00197	0f b6 4d db	 movzx	 ecx, BYTE PTR tv1131[ebp]
  0019b	d1 ea		 shr	 edx, 1
  0019d	88 55 d5	 mov	 BYTE PTR _col_3$[ebp+1], dl
  001a0	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001a3	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001a8	f7 e1		 mul	 ecx
  001aa	d1 ea		 shr	 edx, 1
  001ac	88 55 d4	 mov	 BYTE PTR _col_3$[ebp], dl

; 421  : 	}

  001af	eb 29		 jmp	 SHORT $LN11@Decompress
$LN10@Decompress:

; 422  : 	else
; 423  : 	{
; 424  : 		// Three-color block: derive the other color.
; 425  : 		// 00 = color_0,  01 = color_1,  10 = color_2,
; 426  : 		// 11 = transparent.
; 427  : 		// These two bit codes correspond to the 2-bit fields
; 428  : 		// stored in the 64-bit block.
; 429  : 
; 430  : 		// explicit for each component, unlike some refrasts...
; 431  : 
; 432  : 		// Tracef("block has alpha\n");
; 433  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  001b1	03 c6		 add	 eax, esi

; 440  : 
; 441  : 		col_3->r = 0x00;		// random color to indicate alpha
; 442  : 		col_3->g = 0x00;

  001b3	66 c7 45 d5 00
	00		 mov	 WORD PTR _col_3$[ebp+1], 0
  001b9	d1 e8		 shr	 eax, 1
  001bb	88 45 d2	 mov	 BYTE PTR _col_2$[ebp+2], al
  001be	8b 45 ac	 mov	 eax, DWORD PTR tv1122[ebp]
  001c1	03 c7		 add	 eax, edi

; 443  : 		col_3->b = 0x00;

  001c3	c6 45 d4 00	 mov	 BYTE PTR _col_3$[ebp], 0
  001c7	d1 e8		 shr	 eax, 1
  001c9	88 45 d1	 mov	 BYTE PTR _col_2$[ebp+1], al
  001cc	8b 45 a8	 mov	 eax, DWORD PTR tv1132[ebp]
  001cf	03 c2		 add	 eax, edx

; 444  : 		col_3->a = 0x00;

  001d1	c6 45 d7 00	 mov	 BYTE PTR _col_3$[ebp+3], 0
  001d5	d1 e8		 shr	 eax, 1
  001d7	88 45 d0	 mov	 BYTE PTR _col_2$[ebp], al
$LN11@Decompress:

; 705  : 		{
; 706  : 			// inline func:
; 707  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 708  : 
; 709  : 			pImPos = (DWORD *) ((DWORD) pBase + x * 16 + (y * 4) * nWidth * 4);
; 710  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  001da	8b 55 bc	 mov	 edx, DWORD PTR tv1133[ebp]

; 466  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001dd	33 c0		 xor	 eax, eax
  001df	8b 75 d4	 mov	 esi, DWORD PTR _col_3$[ebp]
  001e2	8b 7d d0	 mov	 edi, DWORD PTR _col_2$[ebp]

; 705  : 		{
; 706  : 			// inline func:
; 707  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 708  : 
; 709  : 			pImPos = (DWORD *) ((DWORD) pBase + x * 16 + (y * 4) * nWidth * 4);
; 710  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  001e5	89 55 c8	 mov	 DWORD PTR _pImPos$1$[ebp], edx

; 466  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001e8	89 45 cc	 mov	 DWORD PTR _y$1$[ebp], eax
  001eb	0f 1f 44 00 00	 npad	 5
$LL16@Decompress:

; 467  : 	{
; 468  : 		// width * 4 bytes per pixel per line
; 469  : 		// each j dxtc row is 4 lines of pixels
; 470  : 
; 471  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 472  : 
; 473  : 		// n steps through pixels
; 474  : 		for (n = 0; n < 4; ++n)

  001f0	33 db		 xor	 ebx, ebx
$LL19@Decompress:

; 475  : 		{
; 476  : 			bits = pColorBlock->row[y] & masks[n];

  001f2	8b 4d b8	 mov	 ecx, DWORD PTR _pBlock$1$[ebp]
  001f5	0f b6 4c 01 04	 movzx	 ecx, BYTE PTR [ecx+eax+4]
  001fa	8b 44 1d ec	 mov	 eax, DWORD PTR _masks$2[ebp+ebx]
  001fe	23 c1		 and	 eax, ecx

; 477  : 			bits >>= shift[n];

  00200	8b 4c 1d dc	 mov	 ecx, DWORD PTR _shift$1[ebp+ebx]
  00204	d3 e8		 shr	 eax, cl

; 478  : 
; 479  : 			switch (bits)

  00206	83 f8 03	 cmp	 eax, 3
  00209	77 1d		 ja	 SHORT $LN26@Decompress
  0020b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN46@Decompress[eax*4]
$LN22@Decompress:

; 480  : 			{
; 481  : 			case 0:
; 482  : 				*pImPos = *col_0;

  00212	8b 45 c4	 mov	 eax, DWORD PTR _col_0$[ebp]
  00215	89 02		 mov	 DWORD PTR [edx], eax

; 483  : 				pImPos++; // increment to next DWORD
; 484  : 				break;

  00217	eb 20		 jmp	 SHORT $LN17@Decompress
$LN23@Decompress:

; 485  : 
; 486  : 			case 1:
; 487  : 				*pImPos = *col_1;

  00219	8b 45 c0	 mov	 eax, DWORD PTR _col_1$[ebp]
  0021c	89 02		 mov	 DWORD PTR [edx], eax

; 488  : 				pImPos++;
; 489  : 				break;

  0021e	eb 19		 jmp	 SHORT $LN17@Decompress
$LN24@Decompress:

; 490  : 
; 491  : 			case 2:
; 492  : 				*pImPos = *col_2;

  00220	89 3a		 mov	 DWORD PTR [edx], edi

; 493  : 				pImPos++;
; 494  : 				break;

  00222	eb 15		 jmp	 SHORT $LN17@Decompress
$LN25@Decompress:

; 495  : 
; 496  : 			case 3:
; 497  : 				*pImPos = *col_3;

  00224	89 32		 mov	 DWORD PTR [edx], esi

; 498  : 				pImPos++;
; 499  : 				break;

  00226	eb 11		 jmp	 SHORT $LN17@Decompress
$LN26@Decompress:

; 500  : 
; 501  : 			default:
; 502  : 				Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  00228	50		 push	 eax
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  0022e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00233	8b 55 c8	 mov	 edx, DWORD PTR _pImPos$1$[ebp]
  00236	83 c4 08	 add	 esp, 8
$LN17@Decompress:

; 467  : 	{
; 468  : 		// width * 4 bytes per pixel per line
; 469  : 		// each j dxtc row is 4 lines of pixels
; 470  : 
; 471  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 472  : 
; 473  : 		// n steps through pixels
; 474  : 		for (n = 0; n < 4; ++n)

  00239	8b 45 cc	 mov	 eax, DWORD PTR _y$1$[ebp]
  0023c	83 c2 04	 add	 edx, 4
  0023f	83 c3 04	 add	 ebx, 4
  00242	89 55 c8	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  00245	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00248	7c a8		 jl	 SHORT $LL19@Decompress

; 464  : 
; 465  : 	// r steps through lines in y
; 466  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  0024a	8b 4d 88	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  0024d	40		 inc	 eax
  0024e	89 45 cc	 mov	 DWORD PTR _y$1$[ebp], eax
  00251	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00254	83 c2 f0	 add	 edx, -16		; fffffff0H
  00257	89 55 c8	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  0025a	83 f8 04	 cmp	 eax, 4
  0025d	7c 91		 jl	 SHORT $LL16@Decompress

; 703  : 
; 704  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  0025f	8b 75 b8	 mov	 esi, DWORD PTR _pBlock$1$[ebp]
  00262	83 45 bc 10	 add	 DWORD PTR tv1133[ebp], 16 ; 00000010H
  00266	83 c6 08	 add	 esi, 8
  00269	83 6d a4 01	 sub	 DWORD PTR tv1146[ebp], 1
  0026d	89 75 b8	 mov	 DWORD PTR _pBlock$1$[ebp], esi
  00270	0f 85 30 fe ff
	ff		 jne	 $LL7@Decompress
  00276	8b 5d 90	 mov	 ebx, DWORD PTR _yblocks$1$[ebp]
  00279	8b 45 98	 mov	 eax, DWORD PTR _pPos$1$[ebp]
  0027c	8b 7d 94	 mov	 edi, DWORD PTR _pdwDest$GSCopy$1$[ebp]
  0027f	8b 4d a0	 mov	 ecx, DWORD PTR _xblocks$1$[ebp]
  00282	8b 55 9c	 mov	 edx, DWORD PTR tv1119[ebp]
$LN2@Decompress:

; 699  : 	for (y = 0; y < yblocks; ++y)

  00285	8d 34 cd 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*8]
  0028c	03 fa		 add	 edi, edx
  0028e	03 c6		 add	 eax, esi
  00290	89 7d 94	 mov	 DWORD PTR _pdwDest$GSCopy$1$[ebp], edi
  00293	83 eb 01	 sub	 ebx, 1
  00296	89 45 98	 mov	 DWORD PTR _pPos$1$[ebp], eax
  00299	89 5d 90	 mov	 DWORD PTR _yblocks$1$[ebp], ebx
  0029c	0f 85 be fd ff
	ff		 jne	 $LL4@Decompress
$LN3@Decompress:

; 711  : 			// Set to RGB test pattern
; 712  : 			//	pImPos = (DWORD*) ((DWORD) pBase + i * 4 + j * m_nWidth * 4);
; 713  : 			//	*pImPos = ((i * 4) << 16) | ((j * 4) << 8) | ((63 - i) * 4);
; 714  : 
; 715  : 			// checkerboard of only col_0 and col_1 basis colors:
; 716  : 			//	pImPos = (DWORD *) ((DWORD) pBase + i * 8 + j * m_nWidth * 8);
; 717  : 			//	*pImPos = *((DWORD *) &col_0);
; 718  : 			//	pImPos += 1 + m_nWidth;
; 719  : 			//	*pImPos = *((DWORD *) &col_1);
; 720  : 		}
; 721  : 	}
; 722  : }

  002a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a5	5f		 pop	 edi
  002a6	5e		 pop	 esi
  002a7	33 cd		 xor	 ecx, ebp
  002a9	5b		 pop	 ebx
  002aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002af	8b e5		 mov	 esp, ebp
  002b1	5d		 pop	 ebp
  002b2	c2 08 00	 ret	 8
  002b5	0f 1f 00	 npad	 3
$LN46@Decompress:
  002b8	00 00 00 00	 DD	 $LN22@Decompress
  002bc	00 00 00 00	 DD	 $LN23@Decompress
  002c0	00 00 00 00	 DD	 $LN24@Decompress
  002c4	00 00 00 00	 DD	 $LN25@Decompress
?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?Decompress@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?Decompress@CDXTCImage@@QAEXHPAK@Z PROC			; CDXTCImage::Decompress, COMDAT
; _this$ = ecx

; 334  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 	switch (m_CompFormat)

  00003	8b 81 ec 00 00
	00		 mov	 eax, DWORD PTR [ecx+236]
  00009	83 f8 05	 cmp	 eax, 5
  0000c	77 1f		 ja	 SHORT $LN8@Decompress
  0000e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@Decompress[eax*4]
$LN4@Decompress:

; 351  : 		break;
; 352  : 
; 353  : 	case PF_UNKNOWN:
; 354  : 		break;
; 355  : 	}
; 356  : }

  00015	5d		 pop	 ebp

; 336  : 	{
; 337  : 	case PF_DXT1:
; 338  : 		DecompressDXT1(miplevel, pdwDest);

  00016	e9 00 00 00 00	 jmp	 ?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT1
$LN5@Decompress:

; 351  : 		break;
; 352  : 
; 353  : 	case PF_UNKNOWN:
; 354  : 		break;
; 355  : 	}
; 356  : }

  0001b	5d		 pop	 ebp

; 339  : 		break;
; 340  : 
; 341  : 	case PF_DXT3:
; 342  : 		DecompressDXT3(miplevel, pdwDest);

  0001c	e9 00 00 00 00	 jmp	 ?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT3
$LN6@Decompress:

; 351  : 		break;
; 352  : 
; 353  : 	case PF_UNKNOWN:
; 354  : 		break;
; 355  : 	}
; 356  : }

  00021	5d		 pop	 ebp

; 343  : 		break;
; 344  : 
; 345  : 	case PF_DXT5:
; 346  : 		DecompressDXT5(miplevel, pdwDest);

  00022	e9 00 00 00 00	 jmp	 ?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT5
$LN7@Decompress:

; 351  : 		break;
; 352  : 
; 353  : 	case PF_UNKNOWN:
; 354  : 		break;
; 355  : 	}
; 356  : }

  00027	5d		 pop	 ebp

; 347  : 		break;
; 348  : 
; 349  : 	case PF_ARGB:
; 350  : 		DecompressARGB(miplevel, pdwDest);

  00028	e9 00 00 00 00	 jmp	 ?DecompressARGB@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressARGB
$LN8@Decompress:

; 351  : 		break;
; 352  : 
; 353  : 	case PF_UNKNOWN:
; 354  : 		break;
; 355  : 	}
; 356  : }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
  00031	0f 1f 00	 npad	 3
$LN10@Decompress:
  00034	00 00 00 00	 DD	 $LN7@Decompress
  00038	00 00 00 00	 DD	 $LN4@Decompress
  0003c	00 00 00 00	 DD	 $LN8@Decompress
  00040	00 00 00 00	 DD	 $LN5@Decompress
  00044	00 00 00 00	 DD	 $LN8@Decompress
  00048	00 00 00 00	 DD	 $LN6@Decompress
?Decompress@CDXTCImage@@QAEXHPAK@Z ENDP			; CDXTCImage::Decompress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?Copy@CDXTCImage@@QAE_NHPAEJ@Z
_TEXT	SEGMENT
_miplevel$ = 8						; size = 4
_pbDest$ = 12						; size = 4
_lDestPitch$ = 16					; size = 4
?Copy@CDXTCImage@@QAE_NHPAEJ@Z PROC			; CDXTCImage::Copy, COMDAT
; _this$ = ecx

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 277  : 	if (!(m_dwFlags & DDSD_MIPMAPCOUNT))

  00003	8b 55 08	 mov	 edx, DWORD PTR _miplevel$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	f7 86 fc 00 00
	00 00 00 02 00	 test	 DWORD PTR [esi+252], 131072 ; 00020000H
  00013	75 0b		 jne	 SHORT $LN3@Copy

; 278  : 		if (miplevel)

  00015	85 d2		 test	 edx, edx
  00017	74 07		 je	 SHORT $LN3@Copy

; 279  : 		{
; 280  : 			return false;

  00019	32 c0		 xor	 al, al
  0001b	5e		 pop	 esi

; 302  : }

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN3@Copy:

; 281  : 		}
; 282  : 
; 283  : 	/*
; 284  : 	DXTColBlock * pBlock;
; 285  : 	WORD * pPos = (WORD *) &m_pbCompBufferByLevels[miplevel][0];
; 286  : 	int xblocks = (m_nWidth >> miplevel) / 4;
; 287  : 	int yblocks = (m_nHeight >> miplevel) / 4;
; 288  : 
; 289  : 	for (int y = 0; y < yblocks; ++y)
; 290  : 	{
; 291  : 		// 8 bytes per block
; 292  : 		pBlock = (DXTColBlock*) ((DWORD) pPos + y * xblocks * 8);
; 293  : 
; 294  : 		memcpy(pbDest, pBlock, xblocks * 8);
; 295  : 		pbDest += lDestPitch;
; 296  : 	}
; 297  : 	*/
; 298  : 
; 299  : 	memcpy(pbDest, m_pbCompBufferByLevels[miplevel], m_lPitch >> (miplevel * 2));

  00020	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00026	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  00029	d3 f8		 sar	 eax, cl
  0002b	50		 push	 eax
  0002c	ff 74 96 04	 push	 DWORD PTR [esi+edx*4+4]
  00030	ff 75 0c	 push	 DWORD PTR _pbDest$[ebp]
  00033	e8 00 00 00 00	 call	 _memcpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 300  : 	pbDest += lDestPitch;
; 301  : 	return true;

  0003b	b0 01		 mov	 al, 1
  0003d	5e		 pop	 esi

; 302  : }

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?Copy@CDXTCImage@@QAE_NHPAEJ@Z ENDP			; CDXTCImage::Copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEH@Z
_TEXT	SEGMENT
_ddsd$ = -128						; size = 124
_this$1$ = -4						; size = 4
_c_pbMap$ = 8						; size = 4
_iSize$ = 12						; size = 4
?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEH@Z PROC	; CDXTCImage::LoadHeaderFromMemory, COMDAT
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H

; 136  : 	//////////////////////////////////////
; 137  : 	// start reading the file
; 138  : 	// from Microsoft's mssdk D3DIM example "Compress"
; 139  : 	DWORD dwMagic;
; 140  : 
; 141  : 	if (iSize < sizeof(DWORD))

  00009	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	83 f8 04	 cmp	 eax, 4
  00015	0f 82 22 01 00
	00		 jb	 $LN18@LoadHeader

; 142  : 		return false;
; 143  : 
; 144  : 	// Read magic number
; 145  : 	dwMagic = *(DWORD *) c_pbMap;
; 146  : 	c_pbMap += sizeof(DWORD);
; 147  : 
; 148  : 	iSize -= sizeof(DWORD);

  0001b	83 c0 fc	 add	 eax, -4			; fffffffcH

; 149  : //!@#
; 150  : //	if (dwMagic != MAKEFOURCC('D','D','S',' '))
; 151  : //		return false;
; 152  : 
; 153  : 	DDSURFACEDESC2 ddsd; // read from dds file
; 154  : 
; 155  : 	if (iSize < sizeof(DDSURFACEDESC2))

  0001e	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00021	0f 82 16 01 00
	00		 jb	 $LN18@LoadHeader

; 156  : 		return false;
; 157  : 
; 158  : 	// Read the surface description
; 159  : 	memcpy(&ddsd, c_pbMap, sizeof(DDSURFACEDESC2));

  00027	8b 5d 08	 mov	 ebx, DWORD PTR _c_pbMap$[ebp]
  0002a	8d 7d 80	 lea	 edi, DWORD PTR _ddsd$[ebp]
  0002d	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00032	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]

; 160  : 	c_pbMap += sizeof(DDSURFACEDESC2);

  00035	83 eb 80	 sub	 ebx, -128		; ffffff80H
  00038	f3 a5		 rep movsd

; 161  : 
; 162  : 	// Does texture have mipmaps?
; 163  : 	m_bMipTexture = (ddsd.dwMipMapCount > 0) ? TRUE : FALSE;

  0003a	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  0003d	8b 7d 98	 mov	 edi, DWORD PTR _ddsd$[ebp+24]

; 164  : 
; 165  : 	// Clear unwanted flags
; 166  : 	// Can't do this!!!  surface not re-created here
; 167  : 	//    ddsd.dwFlags &= (~DDSD_PITCH);
; 168  : 	//    ddsd.dwFlags &= (~DDSD_LINEARSIZE);
; 169  : 
; 170  : 	// Is it DXTC ?
; 171  : 	// I sure hope pixelformat is valid!
; 172  : 	m_xddPixelFormat.dwFlags = ddsd.ddpfPixelFormat.dwFlags;
; 173  : 	m_xddPixelFormat.dwFourCC = ddsd.ddpfPixelFormat.dwFourCC;
; 174  : 	m_xddPixelFormat.dwSize = ddsd.ddpfPixelFormat.dwSize;

  00040	8d 8e 08 01 00
	00		 lea	 ecx, DWORD PTR [esi+264]
  00046	85 ff		 test	 edi, edi

; 175  : 	m_xddPixelFormat.dwRGBBitCount = ddsd.ddpfPixelFormat.dwRGBBitCount;
; 176  : 	m_xddPixelFormat.dwRGBAlphaBitMask = ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
; 177  : 	m_xddPixelFormat.dwRBitMask = ddsd.ddpfPixelFormat.dwRBitMask;
; 178  : 	m_xddPixelFormat.dwGBitMask = ddsd.ddpfPixelFormat.dwGBitMask;
; 179  : 	m_xddPixelFormat.dwBBitMask = ddsd.ddpfPixelFormat.dwBBitMask;
; 180  : 
; 181  : 	DecodePixelFormat(m_strFormat, &m_xddPixelFormat);

  00048	51		 push	 ecx
  00049	0f 95 c0	 setne	 al
  0004c	88 86 f8 00 00
	00		 mov	 BYTE PTR [esi+248], al
  00052	8b 45 cc	 mov	 eax, DWORD PTR _ddsd$[ebp+76]
  00055	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  0005b	8b 45 d0	 mov	 eax, DWORD PTR _ddsd$[ebp+80]
  0005e	89 86 10 01 00
	00		 mov	 DWORD PTR [esi+272], eax
  00064	8b 45 c8	 mov	 eax, DWORD PTR _ddsd$[ebp+72]
  00067	89 01		 mov	 DWORD PTR [ecx], eax
  00069	8b ce		 mov	 ecx, esi
  0006b	8b 45 d4	 mov	 eax, DWORD PTR _ddsd$[ebp+84]
  0006e	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  00074	8b 45 e4	 mov	 eax, DWORD PTR _ddsd$[ebp+100]
  00077	89 86 24 01 00
	00		 mov	 DWORD PTR [esi+292], eax
  0007d	8b 45 d8	 mov	 eax, DWORD PTR _ddsd$[ebp+88]
  00080	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  00086	8b 45 dc	 mov	 eax, DWORD PTR _ddsd$[ebp+92]
  00089	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax
  0008f	8b 45 e0	 mov	 eax, DWORD PTR _ddsd$[ebp+96]
  00092	89 86 20 01 00
	00		 mov	 DWORD PTR [esi+288], eax
  00098	8d 86 cc 00 00
	00		 lea	 eax, DWORD PTR [esi+204]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ; CDXTCImage::DecodePixelFormat

; 182  : 
; 183  : 	if (m_CompFormat != PF_DXT1 &&
; 184  : 			m_CompFormat != PF_DXT3 &&

  000a4	8b 86 ec 00 00
	00		 mov	 eax, DWORD PTR [esi+236]
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	74 0e		 je	 SHORT $LN7@LoadHeader
  000af	83 f8 03	 cmp	 eax, 3
  000b2	74 09		 je	 SHORT $LN7@LoadHeader
  000b4	83 f8 05	 cmp	 eax, 5
  000b7	0f 85 80 00 00
	00		 jne	 $LN18@LoadHeader
$LN7@LoadHeader:

; 185  : 			m_CompFormat != PF_DXT5)
; 186  : 	{
; 187  : 		return false;
; 188  : 	}
; 189  : 
; 190  : 	if (ddsd.dwMipMapCount > MAX_MIPLEVELS)
; 191  : 	{
; 192  : 		ddsd.dwMipMapCount = MAX_MIPLEVELS;
; 193  : 	}
; 194  : 
; 195  : 	m_nWidth		= ddsd.dwWidth;
; 196  : 	m_nHeight		= ddsd.dwHeight;
; 197  : 	//!@#
; 198  : 	m_dwMipMapCount = max(1, ddsd.dwMipMapCount);
; 199  : 	m_dwFlags		= ddsd.dwFlags;

  000bd	8b 4d 84	 mov	 ecx, DWORD PTR _ddsd$[ebp+4]
  000c0	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000c5	3b f8		 cmp	 edi, eax
  000c7	89 8e fc 00 00
	00		 mov	 DWORD PTR [esi+252], ecx
  000cd	0f 47 f8	 cmova	 edi, eax
  000d0	8b 45 8c	 mov	 eax, DWORD PTR _ddsd$[ebp+12]
  000d3	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax
  000d9	8b 45 88	 mov	 eax, DWORD PTR _ddsd$[ebp+8]
  000dc	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax
  000e2	b8 01 00 00 00	 mov	 eax, 1
  000e7	3b f8		 cmp	 edi, eax
  000e9	0f 42 f8	 cmovb	 edi, eax

; 200  : 
; 201  : 	if (ddsd.dwFlags & DDSD_PITCH)

  000ec	8b 45 90	 mov	 eax, DWORD PTR _ddsd$[ebp+16]
  000ef	89 be f4 00 00
	00		 mov	 DWORD PTR [esi+244], edi
  000f5	89 86 f0 00 00
	00		 mov	 DWORD PTR [esi+240], eax
  000fb	f6 c1 08	 test	 cl, 8
  000fe	75 2f		 jne	 SHORT $LN11@LoadHeader

; 202  : 	{
; 203  : 		m_lPitch = ddsd.lPitch;
; 204  : 		m_pbCompBufferByLevels[0] = c_pbMap;
; 205  : 	}
; 206  : 	else
; 207  : 	{
; 208  : 		m_lPitch = ddsd.dwLinearSize;
; 209  : 
; 210  : 		if (ddsd.dwFlags & DDSD_MIPMAPCOUNT)

  00100	f7 c1 00 00 02
	00		 test	 ecx, 131072		; 00020000H
  00106	74 27		 je	 SHORT $LN11@LoadHeader

; 211  : 		{
; 212  : 			for (DWORD dwLinearSize = ddsd.dwLinearSize, i = 0; i < m_dwMipMapCount; ++i, dwLinearSize >>= 2)

  00108	33 d2		 xor	 edx, edx
  0010a	85 ff		 test	 edi, edi
  0010c	74 24		 je	 SHORT $LN12@LoadHeader
  0010e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
$LL4@LoadHeader:

; 213  : 			{
; 214  : 				m_pbCompBufferByLevels[i] = c_pbMap;

  00111	89 19		 mov	 DWORD PTR [ecx], ebx
  00113	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]

; 215  : 				c_pbMap += dwLinearSize;

  00116	03 d8		 add	 ebx, eax
  00118	42		 inc	 edx
  00119	c1 e8 02	 shr	 eax, 2
  0011c	3b 96 f4 00 00
	00		 cmp	 edx, DWORD PTR [esi+244]
  00122	72 ed		 jb	 SHORT $LL4@LoadHeader

; 225  : }

  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	b0 01		 mov	 al, 1
  00128	5b		 pop	 ebx
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 08 00	 ret	 8
$LN11@LoadHeader:

; 216  : 			}
; 217  : 		}
; 218  : 		else
; 219  : 		{
; 220  : 			m_pbCompBufferByLevels[0] = c_pbMap;
; 221  : 		}
; 222  : 	}
; 223  : 
; 224  : 	return true;

  0012f	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
$LN12@LoadHeader:
  00132	5f		 pop	 edi

; 225  : }

  00133	5e		 pop	 esi
  00134	b0 01		 mov	 al, 1
  00136	5b		 pop	 ebx
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 08 00	 ret	 8
$LN18@LoadHeader:
  0013d	5f		 pop	 edi
  0013e	5e		 pop	 esi
  0013f	32 c0		 xor	 al, al
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 08 00	 ret	 8
?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEH@Z ENDP	; CDXTCImage::LoadHeaderFromMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadFromMemory@CDXTCImage@@QAE_NPBEH@Z
_TEXT	SEGMENT
__PFirst$1$ = -8					; size = 4
tv592 = -4						; size = 4
tv580 = 8						; size = 4
_dwBytesPerRow$1$ = 8					; size = 4
_c_pbMap$ = 8						; size = 4
_i$1$ = 12						; size = 4
_yp$1$ = 12						; size = 4
_iSize$ = 12						; size = 4
$T1 = 15						; size = 1
?LoadFromMemory@CDXTCImage@@QAE_NPBEH@Z PROC		; CDXTCImage::LoadFromMemory, COMDAT
; _this$ = ecx

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 230  : 	if (!LoadHeaderFromMemory(c_pbMap, iSize))

  00007	ff 75 0c	 push	 DWORD PTR _iSize$[ebp]
  0000a	8b d9		 mov	 ebx, ecx
  0000c	ff 75 08	 push	 DWORD PTR _c_pbMap$[ebp]
  0000f	e8 00 00 00 00	 call	 ?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEH@Z ; CDXTCImage::LoadHeaderFromMemory
  00014	84 c0		 test	 al, al
  00016	75 07		 jne	 SHORT $LN8@LoadFromMe
  00018	5b		 pop	 ebx

; 273  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
$LN8@LoadFromMe:

; 231  : 	{
; 232  : 		return false;
; 233  : 	}
; 234  : 
; 235  : 	if (m_dwFlags & DDSD_PITCH)

  0001f	8b 83 fc 00 00
	00		 mov	 eax, DWORD PTR [ebx+252]
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	a8 08		 test	 al, 8
  00029	0f 84 82 00 00
	00		 je	 $LN9@LoadFromMe

; 236  : 	{
; 237  : 		DWORD dwBytesPerRow = m_nWidth * m_xddPixelFormat.dwRGBBitCount / 8;

  0002f	8b 8b 14 01 00
	00		 mov	 ecx, DWORD PTR [ebx+276]
  00035	0f af 8b 00 01
	00 00		 imul	 ecx, DWORD PTR [ebx+256]

; 238  : 
; 239  : 		m_nCompSize = m_lPitch * m_nHeight;

  0003c	8b 83 04 01 00
	00		 mov	 eax, DWORD PTR [ebx+260]
  00042	0f af 83 f0 00
	00 00		 imul	 eax, DWORD PTR [ebx+240]
  00049	c1 e9 03	 shr	 ecx, 3
  0004c	89 4d 08	 mov	 DWORD PTR _dwBytesPerRow$1$[ebp], ecx

; 240  : 		m_nCompLineSz = dwBytesPerRow;

  0004f	89 8b c8 00 00
	00		 mov	 DWORD PTR [ebx+200], ecx

; 241  : 
; 242  : 		m_bCompVector[0].resize(m_nCompSize);

  00055	8d 4b 34	 lea	 ecx, DWORD PTR [ebx+52]
  00058	50		 push	 eax
  00059	89 83 c4 00 00
	00		 mov	 DWORD PTR [ebx+196], eax
  0005f	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 246  : 
; 247  : 		for (int yp = 0; yp < m_nHeight; ++yp)

  00064	83 bb 04 01 00
	00 00		 cmp	 DWORD PTR [ebx+260], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1952 :         return _My_data._Myfirst[_Pos];

  0006b	8b 73 34	 mov	 esi, DWORD PTR [ebx+52]
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 245  : 		c_pbMap = m_pbCompBufferByLevels[0];

  0006e	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 246  : 
; 247  : 		for (int yp = 0; yp < m_nHeight; ++yp)

  00071	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _yp$1$[ebp], 0
  00078	0f 8e fc 00 00
	00		 jle	 $LN12@LoadFromMe
  0007e	66 90		 npad	 2
$LL4@LoadFromMe:

; 248  : 		{
; 249  : 			memcpy(pDest, c_pbMap, dwBytesPerRow);

  00080	ff 75 08	 push	 DWORD PTR _dwBytesPerRow$1$[ebp]
  00083	57		 push	 edi
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 _memcpy

; 250  : 			pDest += m_lPitch;

  0008a	8b 83 f0 00 00
	00		 mov	 eax, DWORD PTR [ebx+240]
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	03 f0		 add	 esi, eax

; 251  : 			c_pbMap += m_lPitch;

  00095	03 f8		 add	 edi, eax
  00097	8b 45 0c	 mov	 eax, DWORD PTR _yp$1$[ebp]
  0009a	40		 inc	 eax
  0009b	89 45 0c	 mov	 DWORD PTR _yp$1$[ebp], eax
  0009e	3b 83 04 01 00
	00		 cmp	 eax, DWORD PTR [ebx+260]
  000a4	7c da		 jl	 SHORT $LL4@LoadFromMe

; 268  : 		}
; 269  : 	}
; 270  : 
; 271  : 	// done reading file
; 272  : 	return true;

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	b0 01		 mov	 al, 1
  000aa	5b		 pop	 ebx

; 273  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 08 00	 ret	 8
$LN9@LoadFromMe:

; 252  : 		}
; 253  : 	}
; 254  : 	else
; 255  : 	{
; 256  : 		if (m_dwFlags & DDSD_MIPMAPCOUNT)

  000b1	8b bb f0 00 00
	00		 mov	 edi, DWORD PTR [ebx+240]
  000b7	a9 00 00 02 00	 test	 eax, 131072		; 00020000H
  000bc	0f 84 9d 00 00
	00		 je	 $LN11@LoadFromMe

; 257  : 		{
; 258  : 			for (DWORD dwLinearSize = m_lPitch, i = 0; i < m_dwMipMapCount; ++i, dwLinearSize >>= 2)

  000c2	33 f6		 xor	 esi, esi
  000c4	89 75 0c	 mov	 DWORD PTR _i$1$[ebp], esi
  000c7	39 b3 f4 00 00
	00		 cmp	 DWORD PTR [ebx+244], esi
  000cd	0f 86 a7 00 00
	00		 jbe	 $LN12@LoadFromMe
  000d3	8d 4b 38	 lea	 ecx, DWORD PTR [ebx+56]
  000d6	89 4d 08	 mov	 DWORD PTR tv580[ebp], ecx
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@LoadFromMe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1620 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  000e0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e2	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  000e5	89 45 f8	 mov	 DWORD PTR __PFirst$1$[ebp], eax
  000e8	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  000eb	89 45 fc	 mov	 DWORD PTR tv592[ebp], eax
  000ee	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f0	2b c2		 sub	 eax, edx

; 1621 :         if (_Newsize < _Oldsize) { // trim

  000f2	3b f8		 cmp	 edi, eax
  000f4	73 07		 jae	 SHORT $LN17@LoadFromMe

; 1622 :             const pointer _Newlast = _Myfirst + _Newsize;

  000f6	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]

; 1623 :             _Orphan_range(_Newlast, _Mylast);
; 1624 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1625 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1626 :             _Mylast = _Newlast;

  000f9	89 01		 mov	 DWORD PTR [ecx], eax

; 1627 :             return;

  000fb	eb 31		 jmp	 SHORT $LN18@LoadFromMe
$LN17@LoadFromMe:

; 1628 :         }
; 1629 : 
; 1630 :         if (_Newsize > _Oldsize) { // append

  000fd	76 2f		 jbe	 SHORT $LN18@LoadFromMe

; 1631 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  000ff	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00102	2b c2		 sub	 eax, edx

; 1632 :             if (_Newsize > _Oldcapacity) { // reallocate

  00104	3b f8		 cmp	 edi, eax
  00106	76 0f		 jbe	 SHORT $LN19@LoadFromMe

; 1633 :                 _Resize_reallocate(_Newsize, _Val);

  00108	8b 4d fc	 mov	 ecx, DWORD PTR tv592[ebp]
  0010b	8d 45 0f	 lea	 eax, DWORD PTR $T1[ebp]
  0010e	50		 push	 eax
  0010f	57		 push	 edi
  00110	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1634 :                 return;

  00115	eb 17		 jmp	 SHORT $LN18@LoadFromMe
$LN19@LoadFromMe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1896 :             _Zero_range(_PFirst, _PFirst + _Count);

  00117	8d 34 3a	 lea	 esi, DWORD PTR [edx+edi]
  0011a	56		 push	 esi
  0011b	ff 75 f8	 push	 DWORD PTR __PFirst$1$[ebp]
  0011e	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1643 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00123	8b 45 08	 mov	 eax, DWORD PTR tv580[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1896 :             _Zero_range(_PFirst, _PFirst + _Count);

  00126	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1643 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00129	89 30		 mov	 DWORD PTR [eax], esi
  0012b	8b 75 0c	 mov	 esi, DWORD PTR _i$1$[ebp]
$LN18@LoadFromMe:
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 261  : 				Copy(i, &m_bCompVector[i][0], dwLinearSize);

  0012e	8b 45 fc	 mov	 eax, DWORD PTR tv592[ebp]
  00131	8b cb		 mov	 ecx, ebx
  00133	57		 push	 edi
  00134	ff 30		 push	 DWORD PTR [eax]
  00136	56		 push	 esi
  00137	e8 00 00 00 00	 call	 ?Copy@CDXTCImage@@QAE_NHPAEJ@Z ; CDXTCImage::Copy
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR tv580[ebp]
  0013f	46		 inc	 esi
  00140	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00143	c1 ef 02	 shr	 edi, 2
  00146	89 75 0c	 mov	 DWORD PTR _i$1$[ebp], esi
  00149	89 4d 08	 mov	 DWORD PTR tv580[ebp], ecx
  0014c	3b b3 f4 00 00
	00		 cmp	 esi, DWORD PTR [ebx+244]
  00152	72 8c		 jb	 SHORT $LL7@LoadFromMe

; 268  : 		}
; 269  : 	}
; 270  : 
; 271  : 	// done reading file
; 272  : 	return true;

  00154	5f		 pop	 edi
  00155	5e		 pop	 esi
  00156	b0 01		 mov	 al, 1
  00158	5b		 pop	 ebx

; 273  : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 08 00	 ret	 8
$LN11@LoadFromMe:

; 262  : 			}
; 263  : 		}
; 264  : 		else
; 265  : 		{
; 266  : 			m_bCompVector[0].resize(m_lPitch);

  0015f	57		 push	 edi
  00160	8d 4b 34	 lea	 ecx, DWORD PTR [ebx+52]
  00163	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 267  : 			Copy(0, &m_bCompVector[0][0], m_lPitch);

  00168	ff b3 f0 00 00
	00		 push	 DWORD PTR [ebx+240]
  0016e	8b cb		 mov	 ecx, ebx
  00170	ff 73 34	 push	 DWORD PTR [ebx+52]
  00173	6a 00		 push	 0
  00175	e8 00 00 00 00	 call	 ?Copy@CDXTCImage@@QAE_NHPAEJ@Z ; CDXTCImage::Copy
$LN12@LoadFromMe:

; 268  : 		}
; 269  : 	}
; 270  : 
; 271  : 	// done reading file
; 272  : 	return true;

  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	b0 01		 mov	 al, 1
  0017e	5b		 pop	 ebx

; 273  : }

  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 08 00	 ret	 8
?LoadFromMemory@CDXTCImage@@QAE_NPBEH@Z ENDP		; CDXTCImage::LoadFromMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\string.h
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_pvMap$ = -344						; size = 4
_mappedFile$ = -340					; size = 324
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 4
?LoadFromFile@CDXTCImage@@QAE_NPBD@Z PROC		; CDXTCImage::LoadFromFile, COMDAT
; _this$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx
  00030	8b 7d 08	 mov	 edi, DWORD PTR _filename$[ebp]

; 92   : 	// only understands .dds files for now
; 93   : 	// return true if success
; 94   : 	char * exts[] = { ".DDS" };
; 95   : 	int next = 1;
; 96   : 
; 97   : 	static char fileupper[MAX_PATH + 1];
; 98   : 
; 99   : 	strncpy(fileupper, filename, MAX_PATH);

  00033	68 04 01 00 00	 push	 260			; 00000104H
  00038	57		 push	 edi
  00039	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  0003e	e8 00 00 00 00	 call	 _strncpy

; 100  : 	_strupr(fileupper);

  00043	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  00048	e8 00 00 00 00	 call	 __strupr
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 101  : 
; 102  : 	int i;
; 103  : 	bool knownformat = false;
; 104  : 
; 105  : 	for (i = 0; i < next; ++i)

  00050	33 f6		 xor	 esi, esi
  00052	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL4@LoadFromFi:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_04LFFPHNGG@?4DDS@
  00065	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  0006a	e8 00 00 00 00	 call	 _strstr
  0006f	83 c4 08	 add	 esp, 8
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 109  : 		if (found != NULL)

  00072	85 c0		 test	 eax, eax
  00074	75 18		 jne	 SHORT $LN6@LoadFromFi

; 101  : 
; 102  : 	int i;
; 103  : 	bool knownformat = false;
; 104  : 
; 105  : 	for (i = 0; i < next; ++i)

  00076	46		 inc	 esi
  00077	83 fe 01	 cmp	 esi, 1
  0007a	7c e4		 jl	 SHORT $LL4@LoadFromFi

; 110  : 		{
; 111  : 			knownformat = true;
; 112  : 			break;
; 113  : 		}
; 114  : 	}
; 115  : 
; 116  : 	if (knownformat == false)
; 117  : 	{
; 118  : 		Tracef("Unknown file format encountered! [%s]\n", filename);

  0007c	57		 push	 edi
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@
  00082	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00087	83 c4 08	 add	 esp, 8

; 119  : 		return (false);

  0008a	32 c0		 xor	 al, al
  0008c	eb 67		 jmp	 SHORT $LN1@LoadFromFi
$LN6@LoadFromFi:

; 120  : 	}
; 121  : 
; 122  : 	CMappedFile mappedFile;

  0008e	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  00094	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 123  : 	LPCVOID pvMap;
; 124  : 
; 125  : 	if (!mappedFile.Create(filename, &pvMap, 0, 0))

  00099	6a 00		 push	 0
  0009b	6a 00		 push	 0
  0009d	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _pvMap$[ebp]
  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000aa	50		 push	 eax
  000ab	57		 push	 edi
  000ac	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  000b2	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  000b7	85 c0		 test	 eax, eax
  000b9	75 12		 jne	 SHORT $LN7@LoadFromFi

; 126  : 	{
; 127  : 		Tracef("Can't open file for reading! [%s]\n", filename);

  000bb	57		 push	 edi
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@
  000c1	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  000c6	83 c4 08	 add	 esp, 8
  000c9	32 db		 xor	 bl, bl
  000cb	eb 1b		 jmp	 SHORT $LN10@LoadFromFi
$LN7@LoadFromFi:

; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	return LoadFromMemory((const BYTE*) pvMap, mappedFile.Size());

  000cd	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  000d3	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000d8	50		 push	 eax
  000d9	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _pvMap$[ebp]
  000df	8b cb		 mov	 ecx, ebx
  000e1	e8 00 00 00 00	 call	 ?LoadFromMemory@CDXTCImage@@QAE_NPBEH@Z ; CDXTCImage::LoadFromMemory
  000e6	8a d8		 mov	 bl, al
$LN10@LoadFromFi:
  000e8	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  000ee	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  000f3	8a c3		 mov	 al, bl
$LN1@LoadFromFi:

; 132  : }

  000f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ff	59		 pop	 ecx
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z$0:
  00000	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a a4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-348]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadFromFile@CDXTCImage@@QAE_NPBD@Z ENDP		; CDXTCImage::LoadFromFile
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 2201 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
$T1 = 11						; size = 1
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; _this$ = ecx

; 1653 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 1621 :         if (_Newsize < _Oldsize) { // trim

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00009	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000c	8b 17		 mov	 edx, DWORD PTR [edi]
  0000e	2b c2		 sub	 eax, edx
  00010	3b c8		 cmp	 ecx, eax
  00012	73 0b		 jae	 SHORT $LN4@resize

; 1622 :             const pointer _Newlast = _Myfirst + _Newsize;

  00014	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1623 :             _Orphan_range(_Newlast, _Mylast);
; 1624 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1625 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1626 :             _Mylast = _Newlast;

  00017	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001a	5f		 pop	 edi

; 1654 :         // trim or append value-initialized elements, provide strong guarantee
; 1655 :         _Resize(_Newsize, _Value_init_tag{});
; 1656 :     }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
$LN4@resize:

; 1630 :         if (_Newsize > _Oldsize) { // append

  0001f	76 2e		 jbe	 SHORT $LN5@resize

; 1631 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00021	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00024	2b c2		 sub	 eax, edx

; 1632 :             if (_Newsize > _Oldcapacity) { // reallocate

  00026	3b c8		 cmp	 ecx, eax
  00028	76 11		 jbe	 SHORT $LN6@resize

; 1633 :                 _Resize_reallocate(_Newsize, _Val);

  0002a	8d 45 0b	 lea	 eax, DWORD PTR $T1[ebp]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	8b cf		 mov	 ecx, edi
  00031	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
  00036	5f		 pop	 edi

; 1654 :         // trim or append value-initialized elements, provide strong guarantee
; 1655 :         _Resize(_Newsize, _Value_init_tag{});
; 1656 :     }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN6@resize:
  0003b	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1896 :             _Zero_range(_PFirst, _PFirst + _Count);

  0003c	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]
  0003f	56		 push	 esi
  00040	ff 77 04	 push	 DWORD PTR [edi+4]
  00043	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>
  00048	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1643 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  0004b	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0004e	5e		 pop	 esi
$LN5@resize:
  0004f	5f		 pop	 edi

; 1654 :         // trim or append value-initialized elements, provide strong guarantee
; 1655 :         _Resize(_Newsize, _Value_init_tag{});
; 1656 :     }

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 829  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2107 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 3d		 je	 SHORT $LN4@vector

; 2108 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2109 :             _ASAN_VECTOR_REMOVE;
; 2110 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN20@vector

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 22		 ja	 SHORT $LN17@vector

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN20@vector:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2112 :             _Myfirst = nullptr;

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00035	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2113 :             _Mylast  = nullptr;

  00038	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2114 :             _Myend   = nullptr;

  0003f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00046	5e		 pop	 esi

; 835  :     }

  00047	c3		 ret	 0
$LN17@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@vector:
  0004d	cc		 int	 3
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 674  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 675  :     }

  00006	8b c1		 mov	 eax, ecx

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 674  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 675  :     }

  00016	c3		 ret	 0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?Clear@CDXTCImage@@QAEXXZ
_TEXT	SEGMENT
?Clear@CDXTCImage@@QAEXXZ PROC				; CDXTCImage::Clear, COMDAT
; _this$ = ecx

; 81   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 82   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)

  00003	ba 02 00 00 00	 mov	 edx, 2
  00008	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@Clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1829 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00010	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00013	3b 48 f4	 cmp	 ecx, DWORD PTR [eax-12]
  00016	74 03		 je	 SHORT $LN2@Clear

; 1830 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1831 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1832 :             // N4901 [tab:container.seq.req] "a.clear() [...] may invalidate the past-the-end iterator".
; 1833 :             return;
; 1834 :         }
; 1835 : 
; 1836 :         _My_data._Orphan_all();
; 1837 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1838 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1839 :         _Mylast = _Myfirst;

  00018	89 48 f4	 mov	 DWORD PTR [eax-12], ecx
$LN2@Clear:

; 1829 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0001b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00020	74 02		 je	 SHORT $LN13@Clear

; 1830 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1831 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1832 :             // N4901 [tab:container.seq.req] "a.clear() [...] may invalidate the past-the-end iterator".
; 1833 :             return;
; 1834 :         }
; 1835 : 
; 1836 :         _My_data._Orphan_all();
; 1837 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1838 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1839 :         _Mylast = _Myfirst;

  00022	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@Clear:

; 1829 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00024	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00027	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0002a	74 03		 je	 SHORT $LN14@Clear

; 1830 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1831 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1832 :             // N4901 [tab:container.seq.req] "a.clear() [...] may invalidate the past-the-end iterator".
; 1833 :             return;
; 1834 :         }
; 1835 : 
; 1836 :         _My_data._Orphan_all();
; 1837 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1838 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1839 :         _Mylast = _Myfirst;

  0002c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN14@Clear:

; 1829 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0002f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00032	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00035	74 03		 je	 SHORT $LN15@Clear

; 1830 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1831 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1832 :             // N4901 [tab:container.seq.req] "a.clear() [...] may invalidate the past-the-end iterator".
; 1833 :             return;
; 1834 :         }
; 1835 : 
; 1836 :         _My_data._Orphan_all();
; 1837 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1838 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1839 :         _Mylast = _Myfirst;

  00037	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN15@Clear:

; 1829 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0003a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0003d	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00040	74 03		 je	 SHORT $LN16@Clear

; 1830 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1831 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1832 :             // N4901 [tab:container.seq.req] "a.clear() [...] may invalidate the past-the-end iterator".
; 1833 :             return;
; 1834 :         }
; 1835 : 
; 1836 :         _My_data._Orphan_all();
; 1837 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1838 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1839 :         _Mylast = _Myfirst;

  00042	89 48 24	 mov	 DWORD PTR [eax+36], ecx
$LN16@Clear:

; 1829 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00045	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00048	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  0004b	74 03		 je	 SHORT $LN17@Clear

; 1830 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1831 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1832 :             // N4901 [tab:container.seq.req] "a.clear() [...] may invalidate the past-the-end iterator".
; 1833 :             return;
; 1834 :         }
; 1835 : 
; 1836 :         _My_data._Orphan_all();
; 1837 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1838 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1839 :         _Mylast = _Myfirst;

  0004d	89 48 30	 mov	 DWORD PTR [eax+48], ecx
$LN17@Clear:
  00050	83 c0 48	 add	 eax, 72			; 00000048H
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp

; 82   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)

  00053	83 ea 01	 sub	 edx, 1
  00056	75 b8		 jne	 SHORT $LL4@Clear

; 83   : 	{
; 84   : 		m_bCompVector[i].clear();
; 85   : 	}
; 86   : 
; 87   : 	Initialize();

  00058	8b ce		 mov	 ecx, esi
  0005a	5e		 pop	 esi
  0005b	e9 00 00 00 00	 jmp	 ?Initialize@CDXTCImage@@QAEXXZ ; CDXTCImage::Initialize
?Clear@CDXTCImage@@QAEXXZ ENDP				; CDXTCImage::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ?Initialize@CDXTCImage@@QAEXXZ
_TEXT	SEGMENT
?Initialize@CDXTCImage@@QAEXXZ PROC			; CDXTCImage::Initialize, COMDAT
; _this$ = ecx

; 70   : {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 71   : 	m_nWidth = 0;

  00003	c7 81 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+256], 0

; 72   : 	m_nHeight = 0;

  0000d	c7 81 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+260], 0
  00017	0f 11 41 04	 movups	 XMMWORD PTR [ecx+4], xmm0
  0001b	0f 11 41 14	 movups	 XMMWORD PTR [ecx+20], xmm0
  0001f	0f 11 41 24	 movups	 XMMWORD PTR [ecx+36], xmm0

; 73   : 
; 74   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)
; 75   : 	{
; 76   : 		m_pbCompBufferByLevels[i] = NULL;
; 77   : 	}
; 78   : }

  00023	c3		 ret	 0
?Initialize@CDXTCImage@@QAEXXZ ENDP			; CDXTCImage::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ??1CDXTCImage@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CDXTCImage@@UAE@XZ PROC				; CDXTCImage::~CDXTCImage, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CDXTCImage@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 67   : }

  00022	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00027	6a 0c		 push	 12			; 0000000cH
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	8d 41 34	 lea	 eax, DWORD PTR [ecx+52]
  0002e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDXTCImage@@6B@
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
  00049	cc		 int	 3
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CDXTCImage@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CDXTCImage@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CDXTCImage@@UAE@XZ ENDP				; CDXTCImage::~CDXTCImage
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\eterImageLib\DXTCImage.cpp
;	COMDAT ??0CDXTCImage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CDXTCImage@@QAE@XZ PROC				; CDXTCImage::CDXTCImage, COMDAT
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  0000a	8b f1		 mov	 esi, ecx
  0000c	68 00 00 00 00	 push	 OFFSET ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  00011	6a 0c		 push	 12			; 0000000cH
  00013	6a 0c		 push	 12			; 0000000cH
  00015	8d 46 34	 lea	 eax, DWORD PTR [esi+52]
  00018	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0001b	50		 push	 eax
  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDXTCImage@@6B@
  00022	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z

; 62   : 	Initialize();

  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?Initialize@CDXTCImage@@QAEXXZ ; CDXTCImage::Initialize

; 63   : }

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??0CDXTCImage@@QAE@XZ ENDP				; CDXTCImage::CDXTCImage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 323  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);
; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1952 :         __crt_va_end(_ArgList);
; 1953 :         return _Result;
; 1954 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
