; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31942.0 

	TITLE	C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\Distribute\PythonMarshal.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadObjectFromFile
PUBLIC	?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadLastObjectFromFile
PUBLIC	?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z	; _PyMarshal_ReadLongFromFile
PUBLIC	?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z	; _PyMarshal_ReadShortFromFile
PUBLIC	?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z ; _PyMarshal_ReadObjectFromString
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@ ; `string'
PUBLIC	??_C@_0BB@DCKILJJE@bad?5marshal?5data@		; `string'
PUBLIC	??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@ ; `string'
PUBLIC	??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@ ; `string'
PUBLIC	??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	__fileno:PROC
EXTRN	_fread:PROC
EXTRN	_getc:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	__fstat64i32:PROC
EXTRN	_atof:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__PyUnicodeUCS2_DecodeUTF8:PROC
EXTRN	__imp__PyInt_FromLong:PROC
EXTRN	__imp___PyLong_FromByteArray:PROC
EXTRN	__imp__PyFloat_FromDouble:PROC
EXTRN	__imp__PyComplex_FromCComplex:PROC
EXTRN	__imp__PyString_FromStringAndSize:PROC
EXTRN	__imp__PyTuple_New:PROC
EXTRN	__imp__PyList_New:PROC
EXTRN	__imp__PyList_SetItem:PROC
EXTRN	__imp__PyDict_New:PROC
EXTRN	__imp__PyDict_SetItem:PROC
EXTRN	__imp__PyErr_SetString:PROC
EXTRN	__imp__PyErr_Occurred:PROC
EXTRN	__imp__PyErr_NoMemory:PROC
EXTRN	__imp__PyEval_GetRestricted:PROC
EXTRN	__imp__PyCode_New:PROC
EXTRN	__imp__PyMarshal_ReadObjectFromString:PROC
EXTRN	__imp___PyLong_New:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp___Py_NoneStruct:QWORD
EXTRN	__imp___Py_EllipsisObject:QWORD
EXTRN	__imp__PyExc_StopIteration:DWORD
EXTRN	__imp__PyExc_EOFError:DWORD
EXTRN	__imp__PyExc_RuntimeError:DWORD
EXTRN	__imp__PyExc_ValueError:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@
CONST	SEGMENT
??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@ DB 'XXX rds_objec'
	DB	't called with exception set', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
CONST	SEGMENT
??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@ DB 'XXX rd_object '
	DB	'called with exception set', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@
CONST	SEGMENT
??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@ DB 'cannot unmars'
	DB	'hal code objects in restricted execution mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
CONST	SEGMENT
??_C@_0BB@DCKILJJE@bad?5marshal?5data@ DB 'bad marshal data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
CONST	SEGMENT
??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@ DB 'EOF read where'
	DB	' object expected', 00H			; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_str$ = 8						; size = 4
_len$ = 12						; size = 4
?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z PROC ; _PyMarshal_ReadObjectFromString, COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 527  : 	RFILE rf;
; 528  : 	if (PyErr_Occurred())

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN2@PyMarshal_

; 529  : 	{
; 530  : 		fprintf(stderr, "XXX rds_object called with exception set\n");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001c	83 c4 04	 add	 esp, 4
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _fprintf
  00025	83 c4 08	 add	 esp, 8

; 531  : 		return NULL;

  00028	33 c0		 xor	 eax, eax

; 538  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN2@PyMarshal_:

; 532  : 	}
; 533  : 	rf.fp = NULL;
; 534  : 	rf.str = NULL;
; 535  : 	rf.ptr = str;

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]

; 536  : 	rf.end = str + len;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00034	03 c1		 add	 eax, ecx
  00036	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp], 0
  0003d	89 45 fc	 mov	 DWORD PTR _rf$[ebp+20], eax

; 537  : 	return r_object(&rf);

  00040	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  00043	50		 push	 eax
  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp+12], 0
  0004b	89 4d f8	 mov	 DWORD PTR _rf$[ebp+16], ecx
  0004e	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00053	83 c4 04	 add	 esp, 4

; 538  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z ENDP ; _PyMarshal_ReadObjectFromString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\sys\stat.h
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\sys\stat.h
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?getfilesize@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
_st$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
?getfilesize@@YAJPAU_iobuf@@@Z PROC			; getfilesize, COMDAT

; 444  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]

; 446  : 	if (fstat(fileno(fp), &st) != 0)

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 __fileno
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\sys\stat.h

; 236  :             return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);

  00019	8d 4d cc	 lea	 ecx, DWORD PTR _st$[ebp]
  0001c	51		 push	 ecx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 __fstat64i32
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp

; 446  : 	if (fstat(fileno(fp), &st) != 0)

  00023	8b 4d e0	 mov	 ecx, DWORD PTR _st$[ebp+20]
  00026	83 ca ff	 or	 edx, -1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\sys\stat.h

; 236  :             return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);

  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp

; 446  : 	if (fstat(fileno(fp), &st) != 0)

  0002c	85 c0		 test	 eax, eax
  0002e	0f 45 ca	 cmovne	 ecx, edx
  00031	8b c1		 mov	 eax, ecx

; 447  : 	{
; 448  : 		return -1;
; 449  : 	}
; 450  : 	else
; 451  : 	{
; 452  : 		return st.st_size;
; 453  : 	}
; 454  : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?getfilesize@@YAJPAU_iobuf@@@Z ENDP			; getfilesize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z PROC	; _PyMarshal_ReadShortFromFile, COMDAT

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 430  : 	RFILE rf;
; 431  : 	rf.fp = fp;

  00006	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 432  : 	return r_short(&rf);

  0000c	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  00015	83 c4 04	 add	 esp, 4

; 433  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z ENDP	; _PyMarshal_ReadShortFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_object@@YAPAU_object@@PAUWFILE@@@Z
_TEXT	SEGMENT
_c$1 = -320						; size = 16
_dx$2 = -312						; size = 8
_argcount$1$ = -308					; size = 4
_nlocals$1$ = -304					; size = 4
_stacksize$1$ = -300					; size = 4
_flags$1$ = -296					; size = 4
_code$1$ = -292						; size = 4
_varnames$1$ = -288					; size = 4
_names$1$ = -284					; size = 4
_consts$1$ = -280					; size = 4
_cellvars$1$ = -276					; size = 4
_firstlineno$1$ = -272					; size = 4
_v$6$ = -272						; size = 4
_lnotab$1$ = -268					; size = 4
_ob$1$ = -268						; size = 4
_n$7$ = -268						; size = 4
$T3 = -264						; size = 4
_freevars$1$ = -264					; size = 4
_v$5$ = -264						; size = 4
_v$3$ = -264						; size = 4
_n$8$ = -264						; size = 4
_buf$4 = -260						; size = 256
_buf$5 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
?r_object@@YAPAU_object@@PAUWFILE@@@Z PROC		; r_object, COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00018	57		 push	 edi

; 132  : 	PyObject *v, *v2;
; 133  : 	long i, n;
; 134  : 	int type = r_byte(p);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0001e	89 8d f8 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  00024	85 c0		 test	 eax, eax
  00026	74 10		 je	 SHORT $LN187@r_object
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _getc
  0002e	83 c4 04	 add	 esp, 4
  00031	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00034	8b d0		 mov	 edx, eax
  00036	eb 18		 jmp	 SHORT $LN186@r_object
$LN187@r_object:
  00038	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003b	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0003d	0f 84 3b 08 00
	00		 je	 $LN88@r_object
  00043	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00046	40		 inc	 eax
  00047	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0004a	89 8d f8 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
$LN186@r_object:

; 135  : 
; 136  : 	switch (type)

  00050	42		 inc	 edx
  00051	83 fa 7c	 cmp	 edx, 124		; 0000007cH
  00054	0f 87 9e 02 00
	00		 ja	 $LN249@r_object
  0005a	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN235@r_object[edx]
  00061	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN236@r_object[eax*4]
$LN90@r_object:

; 137  : 	{
; 138  : 
; 139  : 	case EOF:
; 140  : 		PyErr_SetString(PyExc_EOFError,
; 141  : 						"EOF read where object expected");
; 142  : 		return NULL;
; 143  : 
; 144  : 	case TYPE_NULL:
; 145  : 		return NULL;
; 146  : 
; 147  : 	case TYPE_NONE:
; 148  : 		Py_INCREF(Py_None);

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct
  0006d	ff 00		 inc	 DWORD PTR [eax]

; 149  : 		return Py_None;

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007a	33 cd		 xor	 ecx, ebp
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN91@r_object:

; 150  : 
; 151  : 	case TYPE_STOPITER:
; 152  : 		Py_INCREF(PyExc_StopIteration);

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_StopIteration
  0008a	8b 00		 mov	 eax, DWORD PTR [eax]
  0008c	ff 00		 inc	 DWORD PTR [eax]

; 153  : 		return PyExc_StopIteration;

  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_StopIteration
  00093	8b 00		 mov	 eax, DWORD PTR [eax]

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN92@r_object:

; 154  : 
; 155  : 	case TYPE_ELLIPSIS:
; 156  : 		Py_INCREF(Py_Ellipsis);

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_EllipsisObject
  000ab	ff 00		 inc	 DWORD PTR [eax]

; 157  : 		return Py_Ellipsis;

  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_EllipsisObject

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	33 cd		 xor	 ecx, ebp
  000ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
$LN93@r_object:

; 158  : 
; 159  : 	case TYPE_INT:
; 160  : 		return PyInt_FromLong(r_long(p));

  000c3	56		 push	 esi
  000c4	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyInt_FromLong
  000d0	83 c4 08	 add	 esp, 8

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN94@r_object:

; 161  : 
; 162  : 	case TYPE_INT64:
; 163  : 		return r_long64(p);

  000e4	56		 push	 esi
  000e5	e8 00 00 00 00	 call	 ?r_long64@@YAPAU_object@@PAUWFILE@@@Z ; r_long64
  000ea	83 c4 04	 add	 esp, 4

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f3	33 cd		 xor	 ecx, ebp
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
$LN95@r_object:

; 164  : 
; 165  : 	case TYPE_LONG:
; 166  : 	{
; 167  : 		int size;
; 168  : 		PyLongObject* ob;
; 169  : 		n = r_long(p);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00104	8b d8		 mov	 ebx, eax

; 170  : 		size = n < 0 ? -n : n;

  00106	99		 cdq
  00107	8b f8		 mov	 edi, eax
  00109	33 fa		 xor	 edi, edx
  0010b	2b fa		 sub	 edi, edx

; 171  : 		ob = _PyLong_New(size);

  0010d	57		 push	 edi
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___PyLong_New
  00114	83 c4 08	 add	 esp, 8
  00117	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _ob$1$[ebp], eax

; 172  : 		if (ob == NULL)

  0011d	85 c0		 test	 eax, eax
  0011f	0f 84 6e 07 00
	00		 je	 $LN247@r_object

; 173  : 		{
; 174  : 			return NULL;
; 175  : 		}
; 176  : 		ob->ob_size = n;

  00125	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 177  : 		for (i = 0; i < size; i++)

  00128	85 ff		 test	 edi, edi
  0012a	0f 8e 65 07 00
	00		 jle	 $LN1@r_object

; 173  : 		{
; 174  : 			return NULL;
; 175  : 		}
; 176  : 		ob->ob_size = n;

  00130	8d 58 0c	 lea	 ebx, DWORD PTR [eax+12]
$LL6@r_object:

; 178  : 		{
; 179  : 			ob->ob_digit[i] = (short) r_short(p);

  00133	56		 push	 esi
  00134	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  00139	83 c4 04	 add	 esp, 4
  0013c	66 89 03	 mov	 WORD PTR [ebx], ax
  0013f	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]
  00142	83 ef 01	 sub	 edi, 1
  00145	75 ec		 jne	 SHORT $LL6@r_object
  00147	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ob$1$[ebp]

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00153	33 cd		 xor	 ecx, ebp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
$LN97@r_object:

; 180  : 		}
; 181  : 		return (PyObject *) ob;
; 182  : 	}
; 183  : 
; 184  : 	case TYPE_FLOAT:
; 185  : 	{
; 186  : 		char buf[256];
; 187  : 		double dx;
; 188  : 		n = r_byte(p);

  0015e	8b 06		 mov	 eax, DWORD PTR [esi]
  00160	85 c0		 test	 eax, eax
  00162	74 0d		 je	 SHORT $LN191@r_object
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _getc
  0016a	83 c4 04	 add	 esp, 4
  0016d	8b d8		 mov	 ebx, eax
  0016f	eb 13		 jmp	 SHORT $LN190@r_object
$LN191@r_object:
  00171	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00174	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00176	74 09		 je	 SHORT $LN189@r_object
  00178	0f b6 18	 movzx	 ebx, BYTE PTR [eax]
  0017b	40		 inc	 eax
  0017c	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0017f	eb 03		 jmp	 SHORT $LN190@r_object
$LN189@r_object:
  00181	83 cb ff	 or	 ebx, -1
$LN190@r_object:

; 189  : 		if (r_string(buf, (int)n, p) != n)

  00184	56		 push	 esi
  00185	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  0018b	53		 push	 ebx
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH
  00195	3b c3		 cmp	 eax, ebx
  00197	0f 85 e1 06 00
	00		 jne	 $LN88@r_object

; 190  : 		{
; 191  : 			PyErr_SetString(PyExc_EOFError,
; 192  : 							"EOF read where object expected");
; 193  : 			return NULL;
; 194  : 		}
; 195  : 		buf[n] = '\0';

  0019d	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  001a3	0f 83 fd 06 00
	00		 jae	 $LN193@r_object

; 196  : 		PyFPE_START_PROTECT("atof", return 0)
; 197  : 		dx = atof(buf);

  001a9	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  001af	c6 84 1d fc fe
	ff ff 00	 mov	 BYTE PTR _buf$5[ebp+ebx], 0
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 _atof
  001bd	dd 9d c8 fe ff
	ff		 fstp	 QWORD PTR _dx$2[ebp]

; 198  : 		PyFPE_END_PROTECT(dx)
; 199  : 		return PyFloat_FromDouble(dx);

  001c3	f2 0f 10 85 c8
	fe ff ff	 movsd	 xmm0, QWORD PTR _dx$2[ebp]
  001cb	51		 push	 ecx
  001cc	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyFloat_FromDouble
  001d7	83 c4 08	 add	 esp, 8

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx
  001dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e0	33 cd		 xor	 ecx, ebp
  001e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
$LN99@r_object:

; 200  : 	}
; 201  : 
; 202  : #ifndef WITHOUT_COMPLEX
; 203  : 	case TYPE_COMPLEX:
; 204  : 	{
; 205  : 		char buf[256];
; 206  : 		Py_complex c;
; 207  : 		n = r_byte(p);

  001eb	8b 06		 mov	 eax, DWORD PTR [esi]
  001ed	85 c0		 test	 eax, eax
  001ef	74 0d		 je	 SHORT $LN197@r_object
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _getc
  001f7	83 c4 04	 add	 esp, 4
  001fa	8b d8		 mov	 ebx, eax
  001fc	eb 13		 jmp	 SHORT $LN196@r_object
$LN197@r_object:
  001fe	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00201	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00203	74 09		 je	 SHORT $LN195@r_object
  00205	0f b6 18	 movzx	 ebx, BYTE PTR [eax]
  00208	40		 inc	 eax
  00209	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0020c	eb 03		 jmp	 SHORT $LN196@r_object
$LN195@r_object:
  0020e	83 cb ff	 or	 ebx, -1
$LN196@r_object:

; 208  : 		if (r_string(buf, (int)n, p) != n)

  00211	56		 push	 esi
  00212	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  00218	53		 push	 ebx
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00222	3b c3		 cmp	 eax, ebx
  00224	0f 85 54 06 00
	00		 jne	 $LN88@r_object

; 209  : 		{
; 210  : 			PyErr_SetString(PyExc_EOFError,
; 211  : 							"EOF read where object expected");
; 212  : 			return NULL;
; 213  : 		}
; 214  : 		buf[n] = '\0';

  0022a	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00230	0f 83 70 06 00
	00		 jae	 $LN193@r_object

; 215  : 		PyFPE_START_PROTECT("atof", return 0)
; 216  : 		c.real = atof(buf);

  00236	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  0023c	c6 84 1d fc fe
	ff ff 00	 mov	 BYTE PTR _buf$4[ebp+ebx], 0
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 _atof

; 217  : 		PyFPE_END_PROTECT(c)
; 218  : 		n = r_byte(p);

  0024a	8b 06		 mov	 eax, DWORD PTR [esi]
  0024c	83 c4 04	 add	 esp, 4
  0024f	dd 9d c0 fe ff
	ff		 fstp	 QWORD PTR _c$1[ebp]
  00255	85 c0		 test	 eax, eax
  00257	74 0d		 je	 SHORT $LN203@r_object
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 _getc
  0025f	83 c4 04	 add	 esp, 4
  00262	8b d8		 mov	 ebx, eax
  00264	eb 1b		 jmp	 SHORT $LN202@r_object
$LN203@r_object:
  00266	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0026c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0026f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00271	74 0b		 je	 SHORT $LN201@r_object
  00273	0f b6 19	 movzx	 ebx, BYTE PTR [ecx]
  00276	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00279	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0027c	eb 03		 jmp	 SHORT $LN202@r_object
$LN201@r_object:
  0027e	83 cb ff	 or	 ebx, -1
$LN202@r_object:

; 219  : 		if (r_string(buf, (int)n, p) != n)

  00281	56		 push	 esi
  00282	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  00288	53		 push	 ebx
  00289	50		 push	 eax
  0028a	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  0028f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00292	3b c3		 cmp	 eax, ebx
  00294	0f 85 e4 05 00
	00		 jne	 $LN88@r_object

; 220  : 		{
; 221  : 			PyErr_SetString(PyExc_EOFError,
; 222  : 							"EOF read where object expected");
; 223  : 			return NULL;
; 224  : 		}
; 225  : 		buf[n] = '\0';

  0029a	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  002a0	0f 83 00 06 00
	00		 jae	 $LN193@r_object

; 226  : 		PyFPE_START_PROTECT("atof", return 0)
; 227  : 		c.imag = atof(buf);

  002a6	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  002ac	c6 84 1d fc fe
	ff ff 00	 mov	 BYTE PTR _buf$4[ebp+ebx], 0
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 _atof

; 228  : 		PyFPE_END_PROTECT(c)
; 229  : 		return PyComplex_FromCComplex(c);

  002ba	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002bd	8b c4		 mov	 eax, esp
  002bf	dd 9d c8 fe ff
	ff		 fstp	 QWORD PTR _c$1[ebp+8]
  002c5	0f 10 85 c0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _c$1[ebp]
  002cc	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  002cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyComplex_FromCComplex
  002d5	83 c4 10	 add	 esp, 16			; 00000010H

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  002d8	5f		 pop	 edi
  002d9	5e		 pop	 esi
  002da	5b		 pop	 ebx
  002db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002de	33 cd		 xor	 ecx, ebp
  002e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e5	8b e5		 mov	 esp, ebp
  002e7	5d		 pop	 ebp
  002e8	c3		 ret	 0
$LN102@r_object:

; 230  : 	}
; 231  : #endif
; 232  : 
; 233  : 	case TYPE_STRING:
; 234  : 		n = r_long(p);

  002e9	56		 push	 esi
  002ea	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  002ef	8b d8		 mov	 ebx, eax
  002f1	83 c4 04	 add	 esp, 4

; 235  : 		if (n < 0)

  002f4	85 db		 test	 ebx, ebx
  002f6	79 0f		 jns	 SHORT $LN103@r_object
$LN249@r_object:

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  002f8	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_ValueError
  002fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
  00302	e9 81 05 00 00	 jmp	 $LN246@r_object
$LN103@r_object:

; 236  : 		{
; 237  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 238  : 			return NULL;
; 239  : 		}
; 240  : 		v = PyString_FromStringAndSize((char *)NULL, n);

  00307	53		 push	 ebx
  00308	6a 00		 push	 0
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyString_FromStringAndSize
  00310	8b f8		 mov	 edi, eax
  00312	83 c4 08	 add	 esp, 8

; 241  : 		if (v != NULL)

  00315	85 ff		 test	 edi, edi
  00317	74 3a		 je	 SHORT $LN105@r_object

; 242  : 		{
; 243  : 			if (r_string(PyString_AS_STRING(v), (int)n, p) != n)

  00319	56		 push	 esi
  0031a	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  0031d	53		 push	 ebx
  0031e	51		 push	 ecx
  0031f	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  00324	83 c4 0c	 add	 esp, 12			; 0000000cH
  00327	3b c3		 cmp	 eax, ebx
  00329	74 28		 je	 SHORT $LN105@r_object

; 244  : 			{
; 245  : 				Py_DECREF(v);

  0032b	83 07 ff	 add	 DWORD PTR [edi], -1
  0032e	75 0c		 jne	 SHORT $LN7@r_object
  00330	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00333	57		 push	 edi
  00334	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00337	ff d0		 call	 eax
  00339	83 c4 04	 add	 esp, 4
$LN7@r_object:

; 246  : 				v = NULL;
; 247  : 				PyErr_SetString(PyExc_EOFError,

  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  00341	33 ff		 xor	 edi, edi
  00343	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  00348	ff 30		 push	 DWORD PTR [eax]
  0034a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  00350	83 c4 08	 add	 esp, 8
$LN105@r_object:

; 248  : 								"EOF read where object expected");
; 249  : 			}
; 250  : 		}
; 251  : 		return v;

  00353	8b c7		 mov	 eax, edi

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  00355	5f		 pop	 edi
  00356	5e		 pop	 esi
  00357	5b		 pop	 ebx
  00358	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0035b	33 cd		 xor	 ecx, ebp
  0035d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00362	8b e5		 mov	 esp, ebp
  00364	5d		 pop	 ebp
  00365	c3		 ret	 0
$LN108@r_object:

; 252  : 
; 253  : #ifdef Py_USING_UNICODE
; 254  : 	case TYPE_UNICODE:
; 255  : 	{
; 256  : 		char *buffer;
; 257  : 
; 258  : 		n = r_long(p);

  00366	56		 push	 esi
  00367	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  0036c	8b f8		 mov	 edi, eax
  0036e	83 c4 04	 add	 esp, 4

; 259  : 		if (n < 0)

  00371	85 ff		 test	 edi, edi
  00373	78 83		 js	 SHORT $LN249@r_object

; 260  : 		{
; 261  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 262  : 			return NULL;
; 263  : 		}
; 264  : 		buffer = PyMem_NEW(char, n);

  00375	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  0037b	77 7e		 ja	 SHORT $LN229@r_object
  0037d	85 ff		 test	 edi, edi
  0037f	b8 01 00 00 00	 mov	 eax, 1
  00384	0f 45 c7	 cmovne	 eax, edi
  00387	50		 push	 eax
  00388	e8 00 00 00 00	 call	 _malloc
  0038d	8b d8		 mov	 ebx, eax
  0038f	83 c4 04	 add	 esp, 4

; 265  : 		if (buffer == NULL)

  00392	85 db		 test	 ebx, ebx
  00394	74 65		 je	 SHORT $LN229@r_object

; 268  : 		}
; 269  : 		if (r_string(buffer, (int)n, p) != n)

  00396	56		 push	 esi
  00397	57		 push	 edi
  00398	53		 push	 ebx
  00399	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  0039e	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a1	3b c7		 cmp	 eax, edi
  003a3	74 2e		 je	 SHORT $LN111@r_object

; 270  : 		{
; 271  : 			PyMem_DEL(buffer);

  003a5	53		 push	 ebx
  003a6	e8 00 00 00 00	 call	 _free

; 272  : 			PyErr_SetString(PyExc_EOFError,

  003ab	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  003b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  003b5	ff 30		 push	 DWORD PTR [eax]
  003b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  003bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  003c0	33 c0		 xor	 eax, eax
  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	5b		 pop	 ebx
  003c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c8	33 cd		 xor	 ecx, ebp
  003ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c3		 ret	 0
$LN111@r_object:

; 273  : 							"EOF read where object expected");
; 274  : 			return NULL;
; 275  : 		}
; 276  : 		v = PyUnicode_DecodeUTF8(buffer, n, NULL);

  003d3	6a 00		 push	 0
  003d5	57		 push	 edi
  003d6	53		 push	 ebx
  003d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyUnicodeUCS2_DecodeUTF8

; 277  : 		PyMem_DEL(buffer);

  003dd	53		 push	 ebx
  003de	8b f0		 mov	 esi, eax
  003e0	e8 00 00 00 00	 call	 _free
  003e5	83 c4 10	 add	 esp, 16			; 00000010H

; 278  : 		return v;

  003e8	8b c6		 mov	 eax, esi

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  003ea	5f		 pop	 edi
  003eb	5e		 pop	 esi
  003ec	5b		 pop	 ebx
  003ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f0	33 cd		 xor	 ecx, ebp
  003f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f7	8b e5		 mov	 esp, ebp
  003f9	5d		 pop	 ebp
  003fa	c3		 ret	 0
$LN229@r_object:

; 266  : 		{
; 267  : 			return PyErr_NoMemory();

  003fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_NoMemory

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  00401	5f		 pop	 edi
  00402	5e		 pop	 esi
  00403	5b		 pop	 ebx
  00404	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00407	33 cd		 xor	 ecx, ebp
  00409	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040e	8b e5		 mov	 esp, ebp
  00410	5d		 pop	 ebp
  00411	c3		 ret	 0
$LN112@r_object:

; 279  : 	}
; 280  : #endif
; 281  : 
; 282  : 	case TYPE_TUPLE:
; 283  : 		n = r_long(p);

  00412	56		 push	 esi
  00413	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00418	8b d8		 mov	 ebx, eax
  0041a	83 c4 04	 add	 esp, 4
  0041d	89 9d f4 fe ff
	ff		 mov	 DWORD PTR _n$7$[ebp], ebx

; 284  : 		if (n < 0)

  00423	85 db		 test	 ebx, ebx
  00425	0f 88 cd fe ff
	ff		 js	 $LN249@r_object

; 285  : 		{
; 286  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 287  : 			return NULL;
; 288  : 		}
; 289  : 		v = PyTuple_New((int)n);

  0042b	53		 push	 ebx
  0042c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_New
  00432	83 c4 04	 add	 esp, 4
  00435	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _v$3$[ebp], eax

; 290  : 		if (v == NULL)

  0043b	85 c0		 test	 eax, eax
  0043d	0f 84 50 04 00
	00		 je	 $LN247@r_object

; 291  : 		{
; 292  : 			return v;
; 293  : 		}
; 294  : 		for (i = 0; i < n; i++)

  00443	33 ff		 xor	 edi, edi
  00445	85 db		 test	 ebx, ebx
  00447	0f 8e 48 04 00
	00		 jle	 $LN1@r_object
  0044d	8d 58 0c	 lea	 ebx, DWORD PTR [eax+12]
$LL12@r_object:

; 295  : 		{
; 296  : 			v2 = r_object(p);

  00450	56		 push	 esi
  00451	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00456	83 c4 04	 add	 esp, 4

; 297  : 			if ( v2 == NULL )

  00459	85 c0		 test	 eax, eax
  0045b	74 25		 je	 SHORT $LN215@r_object

; 300  : 				v = NULL;
; 301  : 				break;
; 302  : 			}
; 303  : 			PyTuple_SET_ITEM(v, (int)i, v2);

  0045d	89 03		 mov	 DWORD PTR [ebx], eax
  0045f	47		 inc	 edi
  00460	83 c3 04	 add	 ebx, 4
  00463	3b bd f4 fe ff
	ff		 cmp	 edi, DWORD PTR _n$7$[ebp]
  00469	7c e5		 jl	 SHORT $LL12@r_object

; 342  : 			if (key == NULL)

  0046b	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _v$3$[ebp]

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  00471	5f		 pop	 edi
  00472	5e		 pop	 esi
  00473	5b		 pop	 ebx
  00474	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00477	33 cd		 xor	 ecx, ebp
  00479	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0047e	8b e5		 mov	 esp, ebp
  00480	5d		 pop	 ebp
  00481	c3		 ret	 0
$LN215@r_object:

; 298  : 			{
; 299  : 				Py_DECREF(v);

  00482	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _v$3$[ebp]
  00488	83 01 ff	 add	 DWORD PTR [ecx], -1
  0048b	0f 85 02 04 00
	00		 jne	 $LN247@r_object
  00491	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00494	51		 push	 ecx
  00495	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00498	ff d0		 call	 eax
  0049a	83 c4 04	 add	 esp, 4

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  0049d	33 c0		 xor	 eax, eax
  0049f	5f		 pop	 edi
  004a0	5e		 pop	 esi
  004a1	5b		 pop	 ebx
  004a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a5	33 cd		 xor	 ecx, ebp
  004a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ac	8b e5		 mov	 esp, ebp
  004ae	5d		 pop	 ebp
  004af	c3		 ret	 0
$LN118@r_object:

; 304  : 		}
; 305  : 		return v;
; 306  : 
; 307  : 	case TYPE_LIST:
; 308  : 		n = r_long(p);

  004b0	56		 push	 esi
  004b1	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  004b6	83 c4 04	 add	 esp, 4
  004b9	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _n$8$[ebp], eax

; 309  : 		if (n < 0)

  004bf	85 c0		 test	 eax, eax
  004c1	0f 88 31 fe ff
	ff		 js	 $LN249@r_object

; 310  : 		{
; 311  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 312  : 			return NULL;
; 313  : 		}
; 314  : 		v = PyList_New((int)n);

  004c7	50		 push	 eax
  004c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_New
  004ce	8b d8		 mov	 ebx, eax
  004d0	83 c4 04	 add	 esp, 4

; 315  : 		if (v == NULL)

  004d3	85 db		 test	 ebx, ebx
  004d5	0f 84 b8 03 00
	00		 je	 $LN247@r_object

; 316  : 		{
; 317  : 			return v;
; 318  : 		}
; 319  : 		for (i = 0; i < n; i++)

  004db	33 ff		 xor	 edi, edi
  004dd	39 bd f8 fe ff
	ff		 cmp	 DWORD PTR _n$8$[ebp], edi
  004e3	7e 48		 jle	 SHORT $LN17@r_object
$LL18@r_object:

; 320  : 		{
; 321  : 			v2 = r_object(p);

  004e5	56		 push	 esi
  004e6	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  004eb	83 c4 04	 add	 esp, 4

; 322  : 			if ( v2 == NULL )

  004ee	85 c0		 test	 eax, eax
  004f0	74 28		 je	 SHORT $LN216@r_object

; 326  : 				break;
; 327  : 			}
; 328  : 			PyList_SetItem(v, (int)i, v2);

  004f2	50		 push	 eax
  004f3	57		 push	 edi
  004f4	53		 push	 ebx
  004f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_SetItem
  004fb	47		 inc	 edi
  004fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ff	3b bd f8 fe ff
	ff		 cmp	 edi, DWORD PTR _n$8$[ebp]
  00505	7c de		 jl	 SHORT $LL18@r_object

; 329  : 		}
; 330  : 		return v;

  00507	8b c3		 mov	 eax, ebx

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  00509	5f		 pop	 edi
  0050a	5e		 pop	 esi
  0050b	5b		 pop	 ebx
  0050c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0050f	33 cd		 xor	 ecx, ebp
  00511	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00516	8b e5		 mov	 esp, ebp
  00518	5d		 pop	 ebp
  00519	c3		 ret	 0
$LN216@r_object:

; 323  : 			{
; 324  : 				Py_DECREF(v);

  0051a	83 03 ff	 add	 DWORD PTR [ebx], -1
  0051d	75 0c		 jne	 SHORT $LN19@r_object
  0051f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00522	53		 push	 ebx
  00523	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00526	ff d0		 call	 eax
  00528	83 c4 04	 add	 esp, 4
$LN19@r_object:

; 325  : 				v = NULL;

  0052b	33 db		 xor	 ebx, ebx
$LN17@r_object:

; 329  : 		}
; 330  : 		return v;

  0052d	8b c3		 mov	 eax, ebx

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  0052f	5f		 pop	 edi
  00530	5e		 pop	 esi
  00531	5b		 pop	 ebx
  00532	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00535	33 cd		 xor	 ecx, ebp
  00537	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0053c	8b e5		 mov	 esp, ebp
  0053e	5d		 pop	 ebp
  0053f	c3		 ret	 0
$LN124@r_object:

; 331  : 
; 332  : 	case TYPE_DICT:
; 333  : 		v = PyDict_New();

  00540	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_New
  00546	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _v$5$[ebp], eax

; 334  : 		if (v == NULL)

  0054c	85 c0		 test	 eax, eax
  0054e	0f 84 3f 03 00
	00		 je	 $LN247@r_object

; 335  : 		{
; 336  : 			return NULL;
; 337  : 		}
; 338  : 		for (;;)
; 339  : 		{
; 340  : 			PyObject *key, *val;
; 341  : 			key = r_object(p);

  00554	56		 push	 esi
  00555	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0055a	8b d8		 mov	 ebx, eax
  0055c	83 c4 04	 add	 esp, 4

; 342  : 			if (key == NULL)

  0055f	85 db		 test	 ebx, ebx
  00561	74 55		 je	 SHORT $LN217@r_object
$LL22@r_object:

; 343  : 			{
; 344  : 				break;    /* XXX Assume TYPE_NULL, not an error */
; 345  : 			}
; 346  : 			val = r_object(p);

  00563	56		 push	 esi
  00564	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00569	8b f8		 mov	 edi, eax
  0056b	83 c4 04	 add	 esp, 4

; 347  : 			if (val != NULL)

  0056e	85 ff		 test	 edi, edi
  00570	74 11		 je	 SHORT $LN27@r_object

; 348  : 			{
; 349  : 				PyDict_SetItem(v, key, val);

  00572	57		 push	 edi
  00573	53		 push	 ebx
  00574	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _v$5$[ebp]
  0057a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_SetItem
  00580	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@r_object:

; 350  : 			}
; 351  : 			Py_DECREF(key);

  00583	83 03 ff	 add	 DWORD PTR [ebx], -1
  00586	75 0c		 jne	 SHORT $LN25@r_object
  00588	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0058b	53		 push	 ebx
  0058c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0058f	ff d0		 call	 eax
  00591	83 c4 04	 add	 esp, 4
$LN25@r_object:

; 352  : 			Py_XDECREF(val);

  00594	85 ff		 test	 edi, edi
  00596	74 11		 je	 SHORT $LN32@r_object
  00598	83 07 ff	 add	 DWORD PTR [edi], -1
  0059b	75 0c		 jne	 SHORT $LN32@r_object
  0059d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  005a0	57		 push	 edi
  005a1	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  005a4	ff d0		 call	 eax
  005a6	83 c4 04	 add	 esp, 4
$LN32@r_object:

; 335  : 		{
; 336  : 			return NULL;
; 337  : 		}
; 338  : 		for (;;)
; 339  : 		{
; 340  : 			PyObject *key, *val;
; 341  : 			key = r_object(p);

  005a9	56		 push	 esi
  005aa	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  005af	8b d8		 mov	 ebx, eax
  005b1	83 c4 04	 add	 esp, 4

; 342  : 			if (key == NULL)

  005b4	85 db		 test	 ebx, ebx
  005b6	75 ab		 jne	 SHORT $LL22@r_object
$LN217@r_object:

; 353  : 		}
; 354  : 		return v;

  005b8	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _v$5$[ebp]

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  005be	5f		 pop	 edi
  005bf	5e		 pop	 esi
  005c0	5b		 pop	 ebx
  005c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005c4	33 cd		 xor	 ecx, ebp
  005c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005cb	8b e5		 mov	 esp, ebp
  005cd	5d		 pop	 ebp
  005ce	c3		 ret	 0
$LN134@r_object:

; 355  : 
; 356  : 	case TYPE_CODE:
; 357  : 		if (PyEval_GetRestricted())

  005cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyEval_GetRestricted
  005d5	85 c0		 test	 eax, eax
  005d7	74 0f		 je	 SHORT $LN135@r_object

; 358  : 		{
; 359  : 			PyErr_SetString(PyExc_RuntimeError,

  005d9	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  005de	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@

; 360  : 							"cannot unmarshal code objects in "
; 361  : 							"restricted execution mode");
; 362  : 			return NULL;

  005e3	e9 a0 02 00 00	 jmp	 $LN246@r_object
$LN135@r_object:

; 363  : 		}
; 364  : 		else
; 365  : 		{
; 366  : 			int argcount = r_short(p);

  005e8	56		 push	 esi
  005e9	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short

; 367  : 			int nlocals = r_short(p);

  005ee	56		 push	 esi
  005ef	89 85 cc fe ff
	ff		 mov	 DWORD PTR _argcount$1$[ebp], eax
  005f5	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short

; 368  : 			int stacksize = r_short(p);

  005fa	56		 push	 esi
  005fb	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _nlocals$1$[ebp], eax
  00601	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short

; 369  : 			int flags = r_short(p);

  00606	56		 push	 esi
  00607	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _stacksize$1$[ebp], eax
  0060d	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  00612	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _flags$1$[ebp], eax

; 370  : 			PyObject *code = NULL;
; 371  : 			PyObject *consts = NULL;
; 372  : 			PyObject *names = NULL;
; 373  : 			PyObject *varnames = NULL;
; 374  : 			PyObject *freevars = NULL;
; 375  : 			PyObject *cellvars = NULL;
; 376  : 			PyObject *filename = NULL;

  00618	33 db		 xor	 ebx, ebx
  0061a	33 c0		 xor	 eax, eax
  0061c	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _consts$1$[ebp], 0

; 377  : 			PyObject *name = NULL;
; 378  : 			int firstlineno = 0;
; 379  : 			PyObject *lnotab = NULL;
; 380  : 
; 381  : 			code = r_object(p);

  00626	56		 push	 esi
  00627	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _names$1$[ebp], 0
  00631	33 ff		 xor	 edi, edi
  00633	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _varnames$1$[ebp], 0
  0063d	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _freevars$1$[ebp], 0
  00647	89 85 ec fe ff
	ff		 mov	 DWORD PTR _cellvars$1$[ebp], eax
  0064d	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _firstlineno$1$[ebp], eax
  00653	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lnotab$1$[ebp], eax
  00659	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0065e	83 c4 14	 add	 esp, 20			; 00000014H
  00661	89 85 dc fe ff
	ff		 mov	 DWORD PTR _code$1$[ebp], eax

; 382  : 			if (code) { consts = r_object(p); }

  00667	85 c0		 test	 eax, eax
  00669	0f 84 a4 00 00
	00		 je	 $LN244@r_object
  0066f	56		 push	 esi
  00670	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00675	83 c4 04	 add	 esp, 4
  00678	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _consts$1$[ebp], eax

; 383  : 			if (consts) { names = r_object(p); }

  0067e	85 c0		 test	 eax, eax
  00680	0f 84 8d 00 00
	00		 je	 $LN244@r_object
  00686	56		 push	 esi
  00687	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0068c	83 c4 04	 add	 esp, 4
  0068f	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _names$1$[ebp], eax

; 384  : 			if (names) { varnames = r_object(p); }

  00695	85 c0		 test	 eax, eax
  00697	0f 84 76 00 00
	00		 je	 $LN244@r_object
  0069d	56		 push	 esi
  0069e	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006a3	83 c4 04	 add	 esp, 4
  006a6	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _varnames$1$[ebp], eax

; 385  : 			if (varnames) { freevars = r_object(p); }

  006ac	85 c0		 test	 eax, eax
  006ae	74 63		 je	 SHORT $LN244@r_object
  006b0	56		 push	 esi
  006b1	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006b6	83 c4 04	 add	 esp, 4
  006b9	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _freevars$1$[ebp], eax

; 386  : 			if (freevars) { cellvars = r_object(p); }

  006bf	85 c0		 test	 eax, eax
  006c1	74 50		 je	 SHORT $LN244@r_object
  006c3	56		 push	 esi
  006c4	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006c9	83 c4 04	 add	 esp, 4
  006cc	89 85 ec fe ff
	ff		 mov	 DWORD PTR _cellvars$1$[ebp], eax

; 387  : 			if (cellvars) { filename = r_object(p); }

  006d2	85 c0		 test	 eax, eax
  006d4	74 3d		 je	 SHORT $LN244@r_object
  006d6	56		 push	 esi
  006d7	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006dc	8b d8		 mov	 ebx, eax
  006de	83 c4 04	 add	 esp, 4

; 388  : 			if (filename) { name = r_object(p); }

  006e1	85 db		 test	 ebx, ebx
  006e3	74 2e		 je	 SHORT $LN244@r_object
  006e5	56		 push	 esi
  006e6	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  006eb	8b f8		 mov	 edi, eax
  006ed	83 c4 04	 add	 esp, 4

; 389  : 			if (name)

  006f0	85 ff		 test	 edi, edi
  006f2	74 1f		 je	 SHORT $LN244@r_object

; 390  : 			{
; 391  : 				firstlineno = r_short(p);

  006f4	56		 push	 esi
  006f5	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short

; 392  : 				lnotab = r_object(p);

  006fa	56		 push	 esi
  006fb	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _firstlineno$1$[ebp], eax
  00701	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00706	8b f0		 mov	 esi, eax
  00708	83 c4 08	 add	 esp, 8
  0070b	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _lnotab$1$[ebp], esi
  00711	eb 02		 jmp	 SHORT $LN144@r_object
$LN244@r_object:

; 393  : 			}
; 394  : 
; 395  : 			if (!PyErr_Occurred())

  00713	33 f6		 xor	 esi, esi
$LN144@r_object:
  00715	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  0071b	85 c0		 test	 eax, eax
  0071d	75 57		 jne	 SHORT $LN145@r_object

; 396  : 			{
; 397  : 				v = (PyObject *) PyCode_New(

  0071f	56		 push	 esi
  00720	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _firstlineno$1$[ebp]
  00726	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _cellvars$1$[ebp]
  0072c	57		 push	 edi
  0072d	53		 push	 ebx
  0072e	56		 push	 esi
  0072f	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _freevars$1$[ebp]
  00735	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _varnames$1$[ebp]
  0073b	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _names$1$[ebp]
  00741	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _consts$1$[ebp]
  00747	ff b5 dc fe ff
	ff		 push	 DWORD PTR _code$1$[ebp]
  0074d	ff b5 d8 fe ff
	ff		 push	 DWORD PTR _flags$1$[ebp]
  00753	ff b5 d4 fe ff
	ff		 push	 DWORD PTR _stacksize$1$[ebp]
  00759	ff b5 d0 fe ff
	ff		 push	 DWORD PTR _nlocals$1$[ebp]
  0075f	ff b5 cc fe ff
	ff		 push	 DWORD PTR _argcount$1$[ebp]
  00765	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyCode_New
  0076b	83 c4 38	 add	 esp, 56			; 00000038H
  0076e	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _v$6$[ebp], eax

; 398  : 						argcount, nlocals, stacksize, flags,
; 399  : 						code, consts, names, varnames,
; 400  : 						freevars, cellvars, filename, name,
; 401  : 						firstlineno, lnotab);
; 402  : 			}

  00774	eb 10		 jmp	 SHORT $LN36@r_object
$LN145@r_object:
  00776	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _cellvars$1$[ebp]

; 403  : 			else
; 404  : 			{
; 405  : 				v = NULL;

  0077c	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v$6$[ebp], 0
$LN36@r_object:

; 406  : 			}
; 407  : 			Py_XDECREF(code);

  00786	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _code$1$[ebp]
  0078c	85 c9		 test	 ecx, ecx
  0078e	74 11		 je	 SHORT $LN38@r_object
  00790	83 01 ff	 add	 DWORD PTR [ecx], -1
  00793	75 0c		 jne	 SHORT $LN38@r_object
  00795	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00798	51		 push	 ecx
  00799	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0079c	ff d0		 call	 eax
  0079e	83 c4 04	 add	 esp, 4
$LN38@r_object:

; 408  : 			Py_XDECREF(consts);

  007a1	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _consts$1$[ebp]
  007a7	85 c9		 test	 ecx, ecx
  007a9	74 11		 je	 SHORT $LN44@r_object
  007ab	83 01 ff	 add	 DWORD PTR [ecx], -1
  007ae	75 0c		 jne	 SHORT $LN44@r_object
  007b0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007b3	51		 push	 ecx
  007b4	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007b7	ff d0		 call	 eax
  007b9	83 c4 04	 add	 esp, 4
$LN44@r_object:

; 409  : 			Py_XDECREF(names);

  007bc	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _names$1$[ebp]
  007c2	85 c9		 test	 ecx, ecx
  007c4	74 11		 je	 SHORT $LN50@r_object
  007c6	83 01 ff	 add	 DWORD PTR [ecx], -1
  007c9	75 0c		 jne	 SHORT $LN50@r_object
  007cb	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007ce	51		 push	 ecx
  007cf	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007d2	ff d0		 call	 eax
  007d4	83 c4 04	 add	 esp, 4
$LN50@r_object:

; 410  : 			Py_XDECREF(varnames);

  007d7	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _varnames$1$[ebp]
  007dd	85 c9		 test	 ecx, ecx
  007df	74 11		 je	 SHORT $LN56@r_object
  007e1	83 01 ff	 add	 DWORD PTR [ecx], -1
  007e4	75 0c		 jne	 SHORT $LN56@r_object
  007e6	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007e9	51		 push	 ecx
  007ea	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007ed	ff d0		 call	 eax
  007ef	83 c4 04	 add	 esp, 4
$LN56@r_object:

; 411  : 			Py_XDECREF(freevars);

  007f2	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _freevars$1$[ebp]
  007f8	85 c9		 test	 ecx, ecx
  007fa	74 11		 je	 SHORT $LN62@r_object
  007fc	83 01 ff	 add	 DWORD PTR [ecx], -1
  007ff	75 0c		 jne	 SHORT $LN62@r_object
  00801	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00804	51		 push	 ecx
  00805	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00808	ff d0		 call	 eax
  0080a	83 c4 04	 add	 esp, 4
$LN62@r_object:

; 412  : 			Py_XDECREF(cellvars);

  0080d	85 f6		 test	 esi, esi
  0080f	74 11		 je	 SHORT $LN68@r_object
  00811	83 06 ff	 add	 DWORD PTR [esi], -1
  00814	75 0c		 jne	 SHORT $LN68@r_object
  00816	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00819	56		 push	 esi
  0081a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0081d	ff d0		 call	 eax
  0081f	83 c4 04	 add	 esp, 4
$LN68@r_object:

; 413  : 			Py_XDECREF(filename);

  00822	85 db		 test	 ebx, ebx
  00824	74 11		 je	 SHORT $LN74@r_object
  00826	83 03 ff	 add	 DWORD PTR [ebx], -1
  00829	75 0c		 jne	 SHORT $LN74@r_object
  0082b	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0082e	53		 push	 ebx
  0082f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00832	ff d0		 call	 eax
  00834	83 c4 04	 add	 esp, 4
$LN74@r_object:

; 414  : 			Py_XDECREF(name);

  00837	85 ff		 test	 edi, edi
  00839	74 11		 je	 SHORT $LN80@r_object
  0083b	83 07 ff	 add	 DWORD PTR [edi], -1
  0083e	75 0c		 jne	 SHORT $LN80@r_object
  00840	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00843	57		 push	 edi
  00844	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00847	ff d0		 call	 eax
  00849	83 c4 04	 add	 esp, 4
$LN80@r_object:

; 415  : 			Py_XDECREF(lnotab);

  0084c	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lnotab$1$[ebp]
  00852	85 c9		 test	 ecx, ecx
  00854	74 11		 je	 SHORT $LN86@r_object
  00856	83 01 ff	 add	 DWORD PTR [ecx], -1
  00859	75 0c		 jne	 SHORT $LN86@r_object
  0085b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0085e	51		 push	 ecx
  0085f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00862	ff d0		 call	 eax
  00864	83 c4 04	 add	 esp, 4
$LN86@r_object:

; 416  : 
; 417  : 		}
; 418  : 		return v;

  00867	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _v$6$[ebp]

; 419  : 
; 420  : 	default:
; 421  : 		/* Bogus data got written, which isn't ideal.
; 422  : 		   This will let you keep working and recover. */
; 423  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 424  : 		return NULL;
; 425  : 	}
; 426  : }

  0086d	5f		 pop	 edi
  0086e	5e		 pop	 esi
  0086f	5b		 pop	 ebx
  00870	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00873	33 cd		 xor	 ecx, ebp
  00875	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0087a	8b e5		 mov	 esp, ebp
  0087c	5d		 pop	 ebp
  0087d	c3		 ret	 0
$LN88@r_object:
  0087e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  00883	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
$LN246@r_object:
  00888	ff 30		 push	 DWORD PTR [eax]
  0088a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  00890	83 c4 08	 add	 esp, 8
$LN247@r_object:
  00893	33 c0		 xor	 eax, eax
$LN1@r_object:
  00895	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00898	5f		 pop	 edi
  00899	5e		 pop	 esi
  0089a	33 cd		 xor	 ecx, ebp
  0089c	5b		 pop	 ebx
  0089d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008a2	8b e5		 mov	 esp, ebp
  008a4	5d		 pop	 ebp
  008a5	c3		 ret	 0
$LN193@r_object:
  008a6	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN245@r_object:
  008ab	90		 npad	 1
$LN236@r_object:
  008ac	00 00 00 00	 DD	 $LN88@r_object
  008b0	00 00 00 00	 DD	 $LN112@r_object
  008b4	00 00 00 00	 DD	 $LN92@r_object
  008b8	00 00 00 00	 DD	 $LN247@r_object
  008bc	00 00 00 00	 DD	 $LN94@r_object
  008c0	00 00 00 00	 DD	 $LN90@r_object
  008c4	00 00 00 00	 DD	 $LN91@r_object
  008c8	00 00 00 00	 DD	 $LN118@r_object
  008cc	00 00 00 00	 DD	 $LN134@r_object
  008d0	00 00 00 00	 DD	 $LN97@r_object
  008d4	00 00 00 00	 DD	 $LN93@r_object
  008d8	00 00 00 00	 DD	 $LN95@r_object
  008dc	00 00 00 00	 DD	 $LN102@r_object
  008e0	00 00 00 00	 DD	 $LN108@r_object
  008e4	00 00 00 00	 DD	 $LN99@r_object
  008e8	00 00 00 00	 DD	 $LN124@r_object
  008ec	00 00 00 00	 DD	 $LN249@r_object
$LN235@r_object:
  008f0	00		 DB	 0
  008f1	10		 DB	 16			; 00000010H
  008f2	10		 DB	 16			; 00000010H
  008f3	10		 DB	 16			; 00000010H
  008f4	10		 DB	 16			; 00000010H
  008f5	10		 DB	 16			; 00000010H
  008f6	10		 DB	 16			; 00000010H
  008f7	10		 DB	 16			; 00000010H
  008f8	10		 DB	 16			; 00000010H
  008f9	10		 DB	 16			; 00000010H
  008fa	10		 DB	 16			; 00000010H
  008fb	10		 DB	 16			; 00000010H
  008fc	10		 DB	 16			; 00000010H
  008fd	10		 DB	 16			; 00000010H
  008fe	10		 DB	 16			; 00000010H
  008ff	10		 DB	 16			; 00000010H
  00900	10		 DB	 16			; 00000010H
  00901	10		 DB	 16			; 00000010H
  00902	10		 DB	 16			; 00000010H
  00903	10		 DB	 16			; 00000010H
  00904	10		 DB	 16			; 00000010H
  00905	10		 DB	 16			; 00000010H
  00906	10		 DB	 16			; 00000010H
  00907	10		 DB	 16			; 00000010H
  00908	10		 DB	 16			; 00000010H
  00909	10		 DB	 16			; 00000010H
  0090a	10		 DB	 16			; 00000010H
  0090b	10		 DB	 16			; 00000010H
  0090c	10		 DB	 16			; 00000010H
  0090d	10		 DB	 16			; 00000010H
  0090e	10		 DB	 16			; 00000010H
  0090f	10		 DB	 16			; 00000010H
  00910	10		 DB	 16			; 00000010H
  00911	10		 DB	 16			; 00000010H
  00912	10		 DB	 16			; 00000010H
  00913	10		 DB	 16			; 00000010H
  00914	10		 DB	 16			; 00000010H
  00915	10		 DB	 16			; 00000010H
  00916	10		 DB	 16			; 00000010H
  00917	10		 DB	 16			; 00000010H
  00918	10		 DB	 16			; 00000010H
  00919	01		 DB	 1
  0091a	10		 DB	 16			; 00000010H
  0091b	10		 DB	 16			; 00000010H
  0091c	10		 DB	 16			; 00000010H
  0091d	10		 DB	 16			; 00000010H
  0091e	10		 DB	 16			; 00000010H
  0091f	02		 DB	 2
  00920	10		 DB	 16			; 00000010H
  00921	03		 DB	 3
  00922	10		 DB	 16			; 00000010H
  00923	10		 DB	 16			; 00000010H
  00924	10		 DB	 16			; 00000010H
  00925	10		 DB	 16			; 00000010H
  00926	10		 DB	 16			; 00000010H
  00927	10		 DB	 16			; 00000010H
  00928	10		 DB	 16			; 00000010H
  00929	10		 DB	 16			; 00000010H
  0092a	10		 DB	 16			; 00000010H
  0092b	10		 DB	 16			; 00000010H
  0092c	10		 DB	 16			; 00000010H
  0092d	10		 DB	 16			; 00000010H
  0092e	10		 DB	 16			; 00000010H
  0092f	10		 DB	 16			; 00000010H
  00930	10		 DB	 16			; 00000010H
  00931	10		 DB	 16			; 00000010H
  00932	10		 DB	 16			; 00000010H
  00933	10		 DB	 16			; 00000010H
  00934	10		 DB	 16			; 00000010H
  00935	10		 DB	 16			; 00000010H
  00936	10		 DB	 16			; 00000010H
  00937	10		 DB	 16			; 00000010H
  00938	10		 DB	 16			; 00000010H
  00939	10		 DB	 16			; 00000010H
  0093a	04		 DB	 4
  0093b	10		 DB	 16			; 00000010H
  0093c	10		 DB	 16			; 00000010H
  0093d	10		 DB	 16			; 00000010H
  0093e	10		 DB	 16			; 00000010H
  0093f	05		 DB	 5
  00940	10		 DB	 16			; 00000010H
  00941	10		 DB	 16			; 00000010H
  00942	10		 DB	 16			; 00000010H
  00943	10		 DB	 16			; 00000010H
  00944	06		 DB	 6
  00945	10		 DB	 16			; 00000010H
  00946	10		 DB	 16			; 00000010H
  00947	10		 DB	 16			; 00000010H
  00948	10		 DB	 16			; 00000010H
  00949	10		 DB	 16			; 00000010H
  0094a	10		 DB	 16			; 00000010H
  0094b	10		 DB	 16			; 00000010H
  0094c	07		 DB	 7
  0094d	10		 DB	 16			; 00000010H
  0094e	10		 DB	 16			; 00000010H
  0094f	10		 DB	 16			; 00000010H
  00950	10		 DB	 16			; 00000010H
  00951	10		 DB	 16			; 00000010H
  00952	10		 DB	 16			; 00000010H
  00953	10		 DB	 16			; 00000010H
  00954	08		 DB	 8
  00955	10		 DB	 16			; 00000010H
  00956	10		 DB	 16			; 00000010H
  00957	09		 DB	 9
  00958	10		 DB	 16			; 00000010H
  00959	10		 DB	 16			; 00000010H
  0095a	0a		 DB	 10			; 0000000aH
  0095b	10		 DB	 16			; 00000010H
  0095c	10		 DB	 16			; 00000010H
  0095d	0b		 DB	 11			; 0000000bH
  0095e	10		 DB	 16			; 00000010H
  0095f	10		 DB	 16			; 00000010H
  00960	10		 DB	 16			; 00000010H
  00961	10		 DB	 16			; 00000010H
  00962	10		 DB	 16			; 00000010H
  00963	10		 DB	 16			; 00000010H
  00964	0c		 DB	 12			; 0000000cH
  00965	10		 DB	 16			; 00000010H
  00966	0d		 DB	 13			; 0000000dH
  00967	10		 DB	 16			; 00000010H
  00968	10		 DB	 16			; 00000010H
  00969	0e		 DB	 14			; 0000000eH
  0096a	10		 DB	 16			; 00000010H
  0096b	10		 DB	 16			; 00000010H
  0096c	0f		 DB	 15			; 0000000fH
?r_object@@YAPAU_object@@PAUWFILE@@@Z ENDP		; r_object
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_long64@@YAPAU_object@@PAUWFILE@@@Z
_TEXT	SEGMENT
_buf$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
?r_long64@@YAPAU_object@@PAUWFILE@@@Z PROC		; r_long64, COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _p$[ebp]

; 107  : 	long lo4 = r_long(p);

  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long

; 108  : 	long hi4 = r_long(p);

  0001b	57		 push	 edi
  0001c	8b f0		 mov	 esi, eax
  0001e	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long

; 109  : #if SIZEOF_LONG > 4
; 110  : 	long x = (hi4 << 32) | (lo4 & 0xFFFFFFFFL);
; 111  : 	return PyInt_FromLong(x);
; 112  : #else
; 113  : 	unsigned char buf[8];
; 114  : 	int one = 1;
; 115  : 	int is_little_endian = (int) * (char*)&one;
; 116  : 	if (is_little_endian)
; 117  : 	{
; 118  : 		memcpy(buf, &lo4, 4);
; 119  : 		memcpy(buf + 4, &hi4, 4);
; 120  : 	}
; 121  : 	else
; 122  : 	{
; 123  : 		memcpy(buf, &hi4, 4);
; 124  : 		memcpy(buf + 4, &lo4, 4);
; 125  : 	}
; 126  : 	return _PyLong_FromByteArray(buf, 8, is_little_endian, 1);

  00023	6a 01		 push	 1
  00025	6a 01		 push	 1
  00027	89 45 f8	 mov	 DWORD PTR _buf$[ebp+4], eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR _buf$[ebp]
  0002d	6a 08		 push	 8
  0002f	50		 push	 eax
  00030	89 75 f4	 mov	 DWORD PTR _buf$[ebp], esi
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___PyLong_FromByteArray

; 127  : #endif
; 128  : }

  00039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003c	83 c4 18	 add	 esp, 24			; 00000018H
  0003f	33 cd		 xor	 ecx, ebp
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?r_long64@@YAPAU_object@@PAUWFILE@@@Z ENDP		; r_long64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_long@@YAJPAUWFILE@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?r_long@@YAJPAUWFILE@@@Z PROC				; r_long, COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   : 	register long x;
; 76   : 	register FILE *fp = p->fp;

  00003	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 3a		 mov	 edi, DWORD PTR [edx]

; 77   : 	if (fp)

  0000a	85 ff		 test	 edi, edi
  0000c	74 30		 je	 SHORT $LN2@r_long

; 78   : 	{
; 79   : 		x = getc(fp);

  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _getc

; 80   : 		x |= (long)getc(fp) << 8;

  00014	57		 push	 edi
  00015	8b f0		 mov	 esi, eax
  00017	e8 00 00 00 00	 call	 _getc
  0001c	c1 e0 08	 shl	 eax, 8

; 81   : 		x |= (long)getc(fp) << 16;

  0001f	57		 push	 edi
  00020	0b f0		 or	 esi, eax
  00022	e8 00 00 00 00	 call	 _getc
  00027	c1 e0 10	 shl	 eax, 16			; 00000010H

; 82   : 		x |= (long)getc(fp) << 24;

  0002a	57		 push	 edi
  0002b	0b f0		 or	 esi, eax
  0002d	e8 00 00 00 00	 call	 _getc
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	c1 e0 18	 shl	 eax, 24			; 00000018H
  00038	0b c6		 or	 eax, esi
  0003a	5f		 pop	 edi

; 96   : }

  0003b	5e		 pop	 esi
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN2@r_long:

; 83   : 	}
; 84   : 	else
; 85   : 	{
; 86   : 		x = rs_byte(p);

  0003e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00041	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00044	3b ce		 cmp	 ecx, esi
  00046	74 41		 je	 SHORT $LN5@r_long
  00048	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0004b	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0004e	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 87   : 		x |= (long)rs_byte(p) << 8;

  00051	3b fe		 cmp	 edi, esi
  00053	74 37		 je	 SHORT $LN7@r_long
  00055	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00058	47		 inc	 edi
  00059	c1 e1 08	 shl	 ecx, 8
  0005c	0b c8		 or	 ecx, eax
  0005e	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 88   : 		x |= (long)rs_byte(p) << 16;

  00061	3b fe		 cmp	 edi, esi
  00063	74 2e		 je	 SHORT $LN9@r_long
  00065	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00068	47		 inc	 edi
  00069	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006c	0b c8		 or	 ecx, eax
  0006e	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 89   : 		x |= (long)rs_byte(p) << 24;

  00071	3b fe		 cmp	 edi, esi
  00073	74 24		 je	 SHORT $LN11@r_long
  00075	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00078	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0007b	c1 e6 18	 shl	 esi, 24			; 00000018H
  0007e	0b ce		 or	 ecx, esi
  00080	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00083	5f		 pop	 edi

; 90   : 	}
; 91   : #if SIZEOF_LONG > 4
; 92   : 	/* Sign extension for 64-bit machines */
; 93   : 	x |= -(x & 0x80000000L);
; 94   : #endif
; 95   : 	return x;

  00084	8b c1		 mov	 eax, ecx

; 96   : }

  00086	5e		 pop	 esi
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN5@r_long:

; 83   : 	}
; 84   : 	else
; 85   : 	{
; 86   : 		x = rs_byte(p);

  00089	83 c8 ff	 or	 eax, -1
$LN7@r_long:

; 87   : 		x |= (long)rs_byte(p) << 8;

  0008c	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00091	8b c8		 mov	 ecx, eax
$LN9@r_long:

; 88   : 		x |= (long)rs_byte(p) << 16;

  00093	81 c9 00 00 ff
	ff		 or	 ecx, -65536		; ffff0000H
$LN11@r_long:

; 89   : 		x |= (long)rs_byte(p) << 24;

  00099	83 ce ff	 or	 esi, -1
  0009c	c1 e6 18	 shl	 esi, 24			; 00000018H
  0009f	0b ce		 or	 ecx, esi
  000a1	5f		 pop	 edi

; 90   : 	}
; 91   : #if SIZEOF_LONG > 4
; 92   : 	/* Sign extension for 64-bit machines */
; 93   : 	x |= -(x & 0x80000000L);
; 94   : #endif
; 95   : 	return x;

  000a2	8b c1		 mov	 eax, ecx

; 96   : }

  000a4	5e		 pop	 esi
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?r_long@@YAJPAUWFILE@@@Z ENDP				; r_long
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_short@@YAHPAUWFILE@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?r_short@@YAHPAUWFILE@@@Z PROC				; r_short, COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00007	57		 push	 edi

; 65   : 	register short x;
; 66   : 	x = (short) r_byte(p);

  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 11		 je	 SHORT $LN5@r_short
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _getc
  00014	83 c4 04	 add	 esp, 4
  00017	0f b7 f8	 movzx	 edi, ax
  0001a	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  0001d	eb 18		 jmp	 SHORT $LN11@r_short
$LN5@r_short:
  0001f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00022	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00025	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  00028	74 0a		 je	 SHORT $LN3@r_short
  0002a	0f b6 3a	 movzx	 edi, BYTE PTR [edx]
  0002d	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00030	89 01		 mov	 DWORD PTR [ecx], eax
  00032	eb 03		 jmp	 SHORT $LN11@r_short
$LN3@r_short:
  00034	83 cf ff	 or	 edi, -1
$LN11@r_short:

; 67   : 	x |= (short) r_byte(p) << 8;

  00037	8b c6		 mov	 eax, esi
  00039	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  0003e	03 d0		 add	 edx, eax
  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	85 c0		 test	 eax, eax
  00044	74 0d		 je	 SHORT $LN9@r_short
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _getc
  0004c	83 c4 04	 add	 esp, 4
  0004f	8b d0		 mov	 edx, eax
  00051	eb 11		 jmp	 SHORT $LN8@r_short
$LN9@r_short:
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	3b 02		 cmp	 eax, DWORD PTR [edx]
  00057	74 08		 je	 SHORT $LN7@r_short
  00059	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0005c	40		 inc	 eax
  0005d	89 01		 mov	 DWORD PTR [ecx], eax
  0005f	eb 03		 jmp	 SHORT $LN8@r_short
$LN7@r_short:
  00061	83 ca ff	 or	 edx, -1
$LN8@r_short:
  00064	c1 e2 08	 shl	 edx, 8
  00067	0b fa		 or	 edi, edx

; 68   : 	/* Sign-extension, in case short greater than 16 bits */
; 69   : 	x |= -(x & 0x8000);

  00069	8b c7		 mov	 eax, edi
  0006b	0f bf cf	 movsx	 ecx, di
  0006e	25 00 80 ff ff	 and	 eax, -32768		; ffff8000H
  00073	f7 d8		 neg	 eax
  00075	98		 cwde

; 70   : 	return x;

  00076	5f		 pop	 edi
  00077	0b c1		 or	 eax, ecx
  00079	5e		 pop	 esi

; 71   : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?r_short@@YAHPAUWFILE@@@Z ENDP				; r_short
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_string@@YAHPADHPAUWFILE@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_p$ = 16						; size = 4
?r_string@@YAHPADHPAUWFILE@@@Z PROC			; r_string, COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 50   : 	if (p->fp != NULL)

  00004	8b 7d 10	 mov	 edi, DWORD PTR _p$[ebp]
  00007	8b 07		 mov	 eax, DWORD PTR [edi]
  00009	85 c0		 test	 eax, eax
  0000b	74 14		 je	 SHORT $LN2@r_string

; 51   : 	{
; 52   : 		return fread(s, 1, n, p->fp);

  0000d	50		 push	 eax
  0000e	ff 75 0c	 push	 DWORD PTR _n$[ebp]
  00011	6a 01		 push	 1
  00013	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00016	e8 00 00 00 00	 call	 _fread
  0001b	83 c4 10	 add	 esp, 16			; 00000010H
  0001e	5f		 pop	 edi

; 61   : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN2@r_string:

; 53   : 	}
; 54   : 	if (p->end - p->ptr < n)

  00021	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00024	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00027	56		 push	 esi
  00028	8b 75 0c	 mov	 esi, DWORD PTR _n$[ebp]
  0002b	2b ca		 sub	 ecx, edx
  0002d	3b ce		 cmp	 ecx, esi
  0002f	0f 4c f1	 cmovl	 esi, ecx

; 55   : 	{
; 56   : 		n = p->end - p->ptr;
; 57   : 	}
; 58   : 	memcpy(s, p->ptr, n);

  00032	56		 push	 esi
  00033	52		 push	 edx
  00034	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 59   : 	p->ptr += n;
; 60   : 	return n;

  0003f	8b c6		 mov	 eax, esi
  00041	01 77 10	 add	 DWORD PTR [edi+16], esi
  00044	5e		 pop	 esi
  00045	5f		 pop	 edi

; 61   : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?r_string@@YAHPADHPAUWFILE@@@Z ENDP			; r_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z PROC	; _PyMarshal_ReadLongFromFile, COMDAT

; 436  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 437  : 	RFILE rf;
; 438  : 	rf.fp = fp;

  00006	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 439  : 	return r_long(&rf);

  0000c	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00015	83 c4 04	 add	 esp, 4

; 440  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z ENDP	; _PyMarshal_ReadLongFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_buf$1 = -16388						; size = 16384
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z PROC ; _PyMarshal_ReadLastObjectFromFile, COMDAT

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 40 00 00	 mov	 eax, 16388		; 00004004H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _fp$[ebp]

; 464  : 	/* 75% of 2.1's .pyc files can exploit SMALL_FILE_LIMIT.
; 465  : 	 * REASONABLE_FILE_LIMIT is by defn something big enough for Tkinter.pyc.
; 466  : 	 */
; 467  : #define SMALL_FILE_LIMIT (1L << 14)
; 468  : #define REASONABLE_FILE_LIMIT (1L << 18)
; 469  : 
; 470  : 	off_t filesize;
; 471  : 
; 472  : 	if (PyErr_Occurred())

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  00021	85 c0		 test	 eax, eax
  00023	74 29		 je	 SHORT $LN2@PyMarshal_

; 473  : 	{
; 474  : 		fprintf(stderr, "XXX rd_object called with exception set\n");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
  0002a	6a 02		 push	 2
  0002c	e8 00 00 00 00	 call	 ___acrt_iob_func
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _fprintf
  0003a	83 c4 08	 add	 esp, 8

; 475  : 		return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	5b		 pop	 ebx

; 509  : #undef SMALL_FILE_LIMIT
; 510  : #undef REASONABLE_FILE_LIMIT
; 511  : }

  00040	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00043	33 cd		 xor	 ecx, ebp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN2@PyMarshal_:
  0004e	56		 push	 esi
  0004f	57		 push	 edi

; 476  : 	}
; 477  : 
; 478  : 	filesize = getfilesize(fp);

  00050	53		 push	 ebx
  00051	e8 00 00 00 00	 call	 ?getfilesize@@YAJPAU_iobuf@@@Z ; getfilesize
  00056	8b f0		 mov	 esi, eax
  00058	83 c4 04	 add	 esp, 4

; 479  : 	if (filesize > 0)

  0005b	85 f6		 test	 esi, esi
  0005d	0f 8e 92 00 00
	00		 jle	 $LN7@PyMarshal_

; 480  : 	{
; 481  : 		char buf[SMALL_FILE_LIMIT];
; 482  : 		char* pBuf = NULL;
; 483  : 		if (filesize <= SMALL_FILE_LIMIT)

  00063	81 fe 00 40 00
	00		 cmp	 esi, 16384		; 00004000H
  00069	7f 2e		 jg	 SHORT $LN4@PyMarshal_

; 484  : 		{
; 485  : 			pBuf = buf;

  0006b	53		 push	 ebx
  0006c	56		 push	 esi
  0006d	8d bd fc bf ff
	ff		 lea	 edi, DWORD PTR _buf$1[ebp]
  00073	6a 01		 push	 1
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 _fread
  0007b	50		 push	 eax
  0007c	57		 push	 edi
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyMarshal_ReadObjectFromString
  00083	83 c4 18	 add	 esp, 24			; 00000018H
  00086	8b f0		 mov	 esi, eax
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx

; 509  : #undef SMALL_FILE_LIMIT
; 510  : #undef REASONABLE_FILE_LIMIT
; 511  : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN4@PyMarshal_:

; 486  : 		}
; 487  : 		else if (filesize <= REASONABLE_FILE_LIMIT)

  00099	81 fe 00 00 04
	00		 cmp	 esi, 262144		; 00040000H
  0009f	7f 54		 jg	 SHORT $LN7@PyMarshal_

; 488  : 		{
; 489  : 			pBuf = (char *)PyMem_MALLOC(filesize);

  000a1	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  000a7	77 4c		 ja	 SHORT $LN7@PyMarshal_
  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 _malloc
  000af	8b f8		 mov	 edi, eax
  000b1	83 c4 04	 add	 esp, 4

; 490  : 		}
; 491  : 		if (pBuf != NULL)

  000b4	85 ff		 test	 edi, edi
  000b6	74 3d		 je	 SHORT $LN7@PyMarshal_

; 492  : 		{
; 493  : 			PyObject* v;
; 494  : 			size_t n = fread(pBuf, 1, filesize, fp);

  000b8	53		 push	 ebx
  000b9	56		 push	 esi
  000ba	6a 01		 push	 1
  000bc	57		 push	 edi
  000bd	e8 00 00 00 00	 call	 _fread

; 495  : 			v = PyMarshal_ReadObjectFromString(pBuf, n);

  000c2	50		 push	 eax
  000c3	57		 push	 edi
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyMarshal_ReadObjectFromString
  000ca	8b f0		 mov	 esi, eax
  000cc	83 c4 18	 add	 esp, 24			; 00000018H

; 496  : 			if (pBuf != buf)

  000cf	8d 85 fc bf ff
	ff		 lea	 eax, DWORD PTR _buf$1[ebp]
  000d5	3b f8		 cmp	 edi, eax
  000d7	74 09		 je	 SHORT $LN8@PyMarshal_

; 497  : 			{
; 498  : 				PyMem_FREE(pBuf);

  000d9	57		 push	 edi
  000da	e8 00 00 00 00	 call	 _free
  000df	83 c4 04	 add	 esp, 4
$LN8@PyMarshal_:

; 499  : 			}
; 500  : 			return v;

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 509  : #undef SMALL_FILE_LIMIT
; 510  : #undef REASONABLE_FILE_LIMIT
; 511  : }

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN7@PyMarshal_:

; 501  : 		}
; 502  : 
; 503  : 	}
; 504  : 
; 505  : 	/* We don't have fstat, or we do but the file is larger than
; 506  : 	 * REASONABLE_FILE_LIMIT or malloc failed -- read a byte at a time.
; 507  : 	 */
; 508  : 	return _PyMarshal_ReadObjectFromFile(fp);

  000f5	53		 push	 ebx
  000f6	e8 00 00 00 00	 call	 ?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadObjectFromFile

; 509  : #undef SMALL_FILE_LIMIT
; 510  : #undef REASONABLE_FILE_LIMIT
; 511  : }

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	83 c4 04	 add	 esp, 4
  00101	33 cd		 xor	 ecx, ebp
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ENDP ; _PyMarshal_ReadLastObjectFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\flourine\Desktop\Xantios\client-src\Code\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z PROC ; _PyMarshal_ReadObjectFromFile, COMDAT

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 515  : 	RFILE rf;
; 516  : 	if (PyErr_Occurred())

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN2@PyMarshal_

; 517  : 	{
; 518  : 		fprintf(stderr, "XXX rd_object called with exception set\n");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001c	83 c4 04	 add	 esp, 4
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _fprintf
  00025	83 c4 08	 add	 esp, 8

; 519  : 		return NULL;

  00028	33 c0		 xor	 eax, eax

; 523  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN2@PyMarshal_:

; 520  : 	}
; 521  : 	rf.fp = fp;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 522  : 	return r_object(&rf);

  00034	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0003d	83 c4 04	 add	 esp, 4

; 523  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ENDP ; _PyMarshal_ReadObjectFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
